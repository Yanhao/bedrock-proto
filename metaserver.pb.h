// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: metaserver.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_metaserver_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_metaserver_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_metaserver_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_metaserver_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[39]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_metaserver_2eproto;
namespace bedrock {
namespace metaserver {
class AddDataServerRequest;
struct AddDataServerRequestDefaultTypeInternal;
extern AddDataServerRequestDefaultTypeInternal _AddDataServerRequest_default_instance_;
class AddDataServerResponse;
struct AddDataServerResponseDefaultTypeInternal;
extern AddDataServerResponseDefaultTypeInternal _AddDataServerResponse_default_instance_;
class CreateShardRequest;
struct CreateShardRequestDefaultTypeInternal;
extern CreateShardRequestDefaultTypeInternal _CreateShardRequest_default_instance_;
class CreateShardResponse;
struct CreateShardResponseDefaultTypeInternal;
extern CreateShardResponseDefaultTypeInternal _CreateShardResponse_default_instance_;
class CreateStorageRequest;
struct CreateStorageRequestDefaultTypeInternal;
extern CreateStorageRequestDefaultTypeInternal _CreateStorageRequest_default_instance_;
class CreateStorageResponse;
struct CreateStorageResponseDefaultTypeInternal;
extern CreateStorageResponseDefaultTypeInternal _CreateStorageResponse_default_instance_;
class DataServer;
struct DataServerDefaultTypeInternal;
extern DataServerDefaultTypeInternal _DataServer_default_instance_;
class DeleteStorageRequest;
struct DeleteStorageRequestDefaultTypeInternal;
extern DeleteStorageRequestDefaultTypeInternal _DeleteStorageRequest_default_instance_;
class DeleteStorageResponse;
struct DeleteStorageResponseDefaultTypeInternal;
extern DeleteStorageResponseDefaultTypeInternal _DeleteStorageResponse_default_instance_;
class GetShardRoutesByStorageRequest;
struct GetShardRoutesByStorageRequestDefaultTypeInternal;
extern GetShardRoutesByStorageRequestDefaultTypeInternal _GetShardRoutesByStorageRequest_default_instance_;
class GetShardRoutesByStorageResponse;
struct GetShardRoutesByStorageResponseDefaultTypeInternal;
extern GetShardRoutesByStorageResponseDefaultTypeInternal _GetShardRoutesByStorageResponse_default_instance_;
class GetShardRoutesRequest;
struct GetShardRoutesRequestDefaultTypeInternal;
extern GetShardRoutesRequestDefaultTypeInternal _GetShardRoutesRequest_default_instance_;
class GetShardRoutesResponse;
struct GetShardRoutesResponseDefaultTypeInternal;
extern GetShardRoutesResponseDefaultTypeInternal _GetShardRoutesResponse_default_instance_;
class GetStoragesRequest;
struct GetStoragesRequestDefaultTypeInternal;
extern GetStoragesRequestDefaultTypeInternal _GetStoragesRequest_default_instance_;
class GetStoragesResponse;
struct GetStoragesResponseDefaultTypeInternal;
extern GetStoragesResponseDefaultTypeInternal _GetStoragesResponse_default_instance_;
class HeartBeatRequest;
struct HeartBeatRequestDefaultTypeInternal;
extern HeartBeatRequestDefaultTypeInternal _HeartBeatRequest_default_instance_;
class HeartBeatResponse;
struct HeartBeatResponseDefaultTypeInternal;
extern HeartBeatResponseDefaultTypeInternal _HeartBeatResponse_default_instance_;
class ListDataServerRequest;
struct ListDataServerRequestDefaultTypeInternal;
extern ListDataServerRequestDefaultTypeInternal _ListDataServerRequest_default_instance_;
class ListDataServerResponse;
struct ListDataServerResponseDefaultTypeInternal;
extern ListDataServerResponseDefaultTypeInternal _ListDataServerResponse_default_instance_;
class RemoveDataServerRequest;
struct RemoveDataServerRequestDefaultTypeInternal;
extern RemoveDataServerRequestDefaultTypeInternal _RemoveDataServerRequest_default_instance_;
class RemoveDataServerResponse;
struct RemoveDataServerResponseDefaultTypeInternal;
extern RemoveDataServerResponseDefaultTypeInternal _RemoveDataServerResponse_default_instance_;
class RemoveShardRequest;
struct RemoveShardRequestDefaultTypeInternal;
extern RemoveShardRequestDefaultTypeInternal _RemoveShardRequest_default_instance_;
class RemoveShardResponse;
struct RemoveShardResponseDefaultTypeInternal;
extern RemoveShardResponseDefaultTypeInternal _RemoveShardResponse_default_instance_;
class RenameStorageRequest;
struct RenameStorageRequestDefaultTypeInternal;
extern RenameStorageRequestDefaultTypeInternal _RenameStorageRequest_default_instance_;
class RenameStorageResponse;
struct RenameStorageResponseDefaultTypeInternal;
extern RenameStorageResponseDefaultTypeInternal _RenameStorageResponse_default_instance_;
class Replicate;
struct ReplicateDefaultTypeInternal;
extern ReplicateDefaultTypeInternal _Replicate_default_instance_;
class ResizeStorageRequest;
struct ResizeStorageRequestDefaultTypeInternal;
extern ResizeStorageRequestDefaultTypeInternal _ResizeStorageRequest_default_instance_;
class ResizeStorageResponse;
struct ResizeStorageResponseDefaultTypeInternal;
extern ResizeStorageResponseDefaultTypeInternal _ResizeStorageResponse_default_instance_;
class RouteRecord;
struct RouteRecordDefaultTypeInternal;
extern RouteRecordDefaultTypeInternal _RouteRecord_default_instance_;
class Shard;
struct ShardDefaultTypeInternal;
extern ShardDefaultTypeInternal _Shard_default_instance_;
class ShardInfoRequest;
struct ShardInfoRequestDefaultTypeInternal;
extern ShardInfoRequestDefaultTypeInternal _ShardInfoRequest_default_instance_;
class ShardInfoResponse;
struct ShardInfoResponseDefaultTypeInternal;
extern ShardInfoResponseDefaultTypeInternal _ShardInfoResponse_default_instance_;
class ShardList;
struct ShardListDefaultTypeInternal;
extern ShardListDefaultTypeInternal _ShardList_default_instance_;
class ShardRange;
struct ShardRangeDefaultTypeInternal;
extern ShardRangeDefaultTypeInternal _ShardRange_default_instance_;
class Storage;
struct StorageDefaultTypeInternal;
extern StorageDefaultTypeInternal _Storage_default_instance_;
class UndeleteStorageRequest;
struct UndeleteStorageRequestDefaultTypeInternal;
extern UndeleteStorageRequestDefaultTypeInternal _UndeleteStorageRequest_default_instance_;
class UndeleteStorageResponse;
struct UndeleteStorageResponseDefaultTypeInternal;
extern UndeleteStorageResponseDefaultTypeInternal _UndeleteStorageResponse_default_instance_;
class UpdateDataServerRequest;
struct UpdateDataServerRequestDefaultTypeInternal;
extern UpdateDataServerRequestDefaultTypeInternal _UpdateDataServerRequest_default_instance_;
class UpdateDataServerResponse;
struct UpdateDataServerResponseDefaultTypeInternal;
extern UpdateDataServerResponseDefaultTypeInternal _UpdateDataServerResponse_default_instance_;
}  // namespace metaserver
}  // namespace bedrock
PROTOBUF_NAMESPACE_OPEN
template<> ::bedrock::metaserver::AddDataServerRequest* Arena::CreateMaybeMessage<::bedrock::metaserver::AddDataServerRequest>(Arena*);
template<> ::bedrock::metaserver::AddDataServerResponse* Arena::CreateMaybeMessage<::bedrock::metaserver::AddDataServerResponse>(Arena*);
template<> ::bedrock::metaserver::CreateShardRequest* Arena::CreateMaybeMessage<::bedrock::metaserver::CreateShardRequest>(Arena*);
template<> ::bedrock::metaserver::CreateShardResponse* Arena::CreateMaybeMessage<::bedrock::metaserver::CreateShardResponse>(Arena*);
template<> ::bedrock::metaserver::CreateStorageRequest* Arena::CreateMaybeMessage<::bedrock::metaserver::CreateStorageRequest>(Arena*);
template<> ::bedrock::metaserver::CreateStorageResponse* Arena::CreateMaybeMessage<::bedrock::metaserver::CreateStorageResponse>(Arena*);
template<> ::bedrock::metaserver::DataServer* Arena::CreateMaybeMessage<::bedrock::metaserver::DataServer>(Arena*);
template<> ::bedrock::metaserver::DeleteStorageRequest* Arena::CreateMaybeMessage<::bedrock::metaserver::DeleteStorageRequest>(Arena*);
template<> ::bedrock::metaserver::DeleteStorageResponse* Arena::CreateMaybeMessage<::bedrock::metaserver::DeleteStorageResponse>(Arena*);
template<> ::bedrock::metaserver::GetShardRoutesByStorageRequest* Arena::CreateMaybeMessage<::bedrock::metaserver::GetShardRoutesByStorageRequest>(Arena*);
template<> ::bedrock::metaserver::GetShardRoutesByStorageResponse* Arena::CreateMaybeMessage<::bedrock::metaserver::GetShardRoutesByStorageResponse>(Arena*);
template<> ::bedrock::metaserver::GetShardRoutesRequest* Arena::CreateMaybeMessage<::bedrock::metaserver::GetShardRoutesRequest>(Arena*);
template<> ::bedrock::metaserver::GetShardRoutesResponse* Arena::CreateMaybeMessage<::bedrock::metaserver::GetShardRoutesResponse>(Arena*);
template<> ::bedrock::metaserver::GetStoragesRequest* Arena::CreateMaybeMessage<::bedrock::metaserver::GetStoragesRequest>(Arena*);
template<> ::bedrock::metaserver::GetStoragesResponse* Arena::CreateMaybeMessage<::bedrock::metaserver::GetStoragesResponse>(Arena*);
template<> ::bedrock::metaserver::HeartBeatRequest* Arena::CreateMaybeMessage<::bedrock::metaserver::HeartBeatRequest>(Arena*);
template<> ::bedrock::metaserver::HeartBeatResponse* Arena::CreateMaybeMessage<::bedrock::metaserver::HeartBeatResponse>(Arena*);
template<> ::bedrock::metaserver::ListDataServerRequest* Arena::CreateMaybeMessage<::bedrock::metaserver::ListDataServerRequest>(Arena*);
template<> ::bedrock::metaserver::ListDataServerResponse* Arena::CreateMaybeMessage<::bedrock::metaserver::ListDataServerResponse>(Arena*);
template<> ::bedrock::metaserver::RemoveDataServerRequest* Arena::CreateMaybeMessage<::bedrock::metaserver::RemoveDataServerRequest>(Arena*);
template<> ::bedrock::metaserver::RemoveDataServerResponse* Arena::CreateMaybeMessage<::bedrock::metaserver::RemoveDataServerResponse>(Arena*);
template<> ::bedrock::metaserver::RemoveShardRequest* Arena::CreateMaybeMessage<::bedrock::metaserver::RemoveShardRequest>(Arena*);
template<> ::bedrock::metaserver::RemoveShardResponse* Arena::CreateMaybeMessage<::bedrock::metaserver::RemoveShardResponse>(Arena*);
template<> ::bedrock::metaserver::RenameStorageRequest* Arena::CreateMaybeMessage<::bedrock::metaserver::RenameStorageRequest>(Arena*);
template<> ::bedrock::metaserver::RenameStorageResponse* Arena::CreateMaybeMessage<::bedrock::metaserver::RenameStorageResponse>(Arena*);
template<> ::bedrock::metaserver::Replicate* Arena::CreateMaybeMessage<::bedrock::metaserver::Replicate>(Arena*);
template<> ::bedrock::metaserver::ResizeStorageRequest* Arena::CreateMaybeMessage<::bedrock::metaserver::ResizeStorageRequest>(Arena*);
template<> ::bedrock::metaserver::ResizeStorageResponse* Arena::CreateMaybeMessage<::bedrock::metaserver::ResizeStorageResponse>(Arena*);
template<> ::bedrock::metaserver::RouteRecord* Arena::CreateMaybeMessage<::bedrock::metaserver::RouteRecord>(Arena*);
template<> ::bedrock::metaserver::Shard* Arena::CreateMaybeMessage<::bedrock::metaserver::Shard>(Arena*);
template<> ::bedrock::metaserver::ShardInfoRequest* Arena::CreateMaybeMessage<::bedrock::metaserver::ShardInfoRequest>(Arena*);
template<> ::bedrock::metaserver::ShardInfoResponse* Arena::CreateMaybeMessage<::bedrock::metaserver::ShardInfoResponse>(Arena*);
template<> ::bedrock::metaserver::ShardList* Arena::CreateMaybeMessage<::bedrock::metaserver::ShardList>(Arena*);
template<> ::bedrock::metaserver::ShardRange* Arena::CreateMaybeMessage<::bedrock::metaserver::ShardRange>(Arena*);
template<> ::bedrock::metaserver::Storage* Arena::CreateMaybeMessage<::bedrock::metaserver::Storage>(Arena*);
template<> ::bedrock::metaserver::UndeleteStorageRequest* Arena::CreateMaybeMessage<::bedrock::metaserver::UndeleteStorageRequest>(Arena*);
template<> ::bedrock::metaserver::UndeleteStorageResponse* Arena::CreateMaybeMessage<::bedrock::metaserver::UndeleteStorageResponse>(Arena*);
template<> ::bedrock::metaserver::UpdateDataServerRequest* Arena::CreateMaybeMessage<::bedrock::metaserver::UpdateDataServerRequest>(Arena*);
template<> ::bedrock::metaserver::UpdateDataServerResponse* Arena::CreateMaybeMessage<::bedrock::metaserver::UpdateDataServerResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bedrock {
namespace metaserver {

// ===================================================================

class Storage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.Storage) */ {
 public:
  inline Storage() : Storage(nullptr) {}
  ~Storage() override;
  explicit constexpr Storage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Storage(const Storage& from);
  Storage(Storage&& from) noexcept
    : Storage() {
    *this = ::std::move(from);
  }

  inline Storage& operator=(const Storage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Storage& operator=(Storage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Storage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Storage* internal_default_instance() {
    return reinterpret_cast<const Storage*>(
               &_Storage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Storage& a, Storage& b) {
    a.Swap(&b);
  }
  inline void Swap(Storage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Storage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Storage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Storage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Storage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Storage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Storage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.Storage";
  }
  protected:
  explicit Storage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kOwnerFieldNumber = 5,
    kDeletedTsFieldNumber = 3,
    kCreateTsFieldNumber = 4,
    kIdFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string owner = 5;
  void clear_owner();
  const std::string& owner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner();
  PROTOBUF_NODISCARD std::string* release_owner();
  void set_allocated_owner(std::string* owner);
  private:
  const std::string& _internal_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner(const std::string& value);
  std::string* _internal_mutable_owner();
  public:

  // .google.protobuf.Timestamp deleted_ts = 3;
  bool has_deleted_ts() const;
  private:
  bool _internal_has_deleted_ts() const;
  public:
  void clear_deleted_ts();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& deleted_ts() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_deleted_ts();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_deleted_ts();
  void set_allocated_deleted_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_ts);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_deleted_ts() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_deleted_ts();
  public:
  void unsafe_arena_set_allocated_deleted_ts(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_ts);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_deleted_ts();

  // .google.protobuf.Timestamp create_ts = 4;
  bool has_create_ts() const;
  private:
  bool _internal_has_create_ts() const;
  public:
  void clear_create_ts();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& create_ts() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_create_ts();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_create_ts();
  void set_allocated_create_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* create_ts);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_create_ts() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_create_ts();
  public:
  void unsafe_arena_set_allocated_create_ts(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* create_ts);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_create_ts();

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.Storage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_ts_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* create_ts_;
  uint64_t id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class Shard final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.Shard) */ {
 public:
  inline Shard() : Shard(nullptr) {}
  ~Shard() override;
  explicit constexpr Shard(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Shard(const Shard& from);
  Shard(Shard&& from) noexcept
    : Shard() {
    *this = ::std::move(from);
  }

  inline Shard& operator=(const Shard& from) {
    CopyFrom(from);
    return *this;
  }
  inline Shard& operator=(Shard&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Shard& default_instance() {
    return *internal_default_instance();
  }
  static inline const Shard* internal_default_instance() {
    return reinterpret_cast<const Shard*>(
               &_Shard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Shard& a, Shard& b) {
    a.Swap(&b);
  }
  inline void Swap(Shard* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Shard* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Shard* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Shard>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Shard& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Shard& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Shard* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.Shard";
  }
  protected:
  explicit Shard(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplicatesFieldNumber = 4,
    kLeaderFieldNumber = 8,
    kReplicaUpdateTsFieldNumber = 3,
    kDeletedTsFieldNumber = 6,
    kCreateTsFieldNumber = 7,
    kLeaderChangeTsFieldNumber = 9,
    kIdFieldNumber = 1,
    kStorageIdFieldNumber = 2,
    kIsDeletedFieldNumber = 5,
  };
  // repeated string replicates = 4;
  int replicates_size() const;
  private:
  int _internal_replicates_size() const;
  public:
  void clear_replicates();
  const std::string& replicates(int index) const;
  std::string* mutable_replicates(int index);
  void set_replicates(int index, const std::string& value);
  void set_replicates(int index, std::string&& value);
  void set_replicates(int index, const char* value);
  void set_replicates(int index, const char* value, size_t size);
  std::string* add_replicates();
  void add_replicates(const std::string& value);
  void add_replicates(std::string&& value);
  void add_replicates(const char* value);
  void add_replicates(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& replicates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_replicates();
  private:
  const std::string& _internal_replicates(int index) const;
  std::string* _internal_add_replicates();
  public:

  // string leader = 8;
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_NODISCARD std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // .google.protobuf.Timestamp replica_update_ts = 3;
  bool has_replica_update_ts() const;
  private:
  bool _internal_has_replica_update_ts() const;
  public:
  void clear_replica_update_ts();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& replica_update_ts() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_replica_update_ts();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_replica_update_ts();
  void set_allocated_replica_update_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* replica_update_ts);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_replica_update_ts() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_replica_update_ts();
  public:
  void unsafe_arena_set_allocated_replica_update_ts(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* replica_update_ts);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_replica_update_ts();

  // .google.protobuf.Timestamp deleted_ts = 6;
  bool has_deleted_ts() const;
  private:
  bool _internal_has_deleted_ts() const;
  public:
  void clear_deleted_ts();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& deleted_ts() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_deleted_ts();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_deleted_ts();
  void set_allocated_deleted_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_ts);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_deleted_ts() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_deleted_ts();
  public:
  void unsafe_arena_set_allocated_deleted_ts(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_ts);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_deleted_ts();

  // .google.protobuf.Timestamp create_ts = 7;
  bool has_create_ts() const;
  private:
  bool _internal_has_create_ts() const;
  public:
  void clear_create_ts();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& create_ts() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_create_ts();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_create_ts();
  void set_allocated_create_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* create_ts);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_create_ts() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_create_ts();
  public:
  void unsafe_arena_set_allocated_create_ts(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* create_ts);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_create_ts();

  // .google.protobuf.Timestamp leader_change_ts = 9;
  bool has_leader_change_ts() const;
  private:
  bool _internal_has_leader_change_ts() const;
  public:
  void clear_leader_change_ts();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& leader_change_ts() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_leader_change_ts();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_leader_change_ts();
  void set_allocated_leader_change_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* leader_change_ts);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_leader_change_ts() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_leader_change_ts();
  public:
  void unsafe_arena_set_allocated_leader_change_ts(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* leader_change_ts);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_leader_change_ts();

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // uint64 storage_id = 2;
  void clear_storage_id();
  uint64_t storage_id() const;
  void set_storage_id(uint64_t value);
  private:
  uint64_t _internal_storage_id() const;
  void _internal_set_storage_id(uint64_t value);
  public:

  // bool is_deleted = 5;
  void clear_is_deleted();
  bool is_deleted() const;
  void set_is_deleted(bool value);
  private:
  bool _internal_is_deleted() const;
  void _internal_set_is_deleted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.Shard)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> replicates_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* replica_update_ts_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_ts_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* create_ts_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* leader_change_ts_;
  uint64_t id_;
  uint64_t storage_id_;
  bool is_deleted_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class DataServer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.DataServer) */ {
 public:
  inline DataServer() : DataServer(nullptr) {}
  ~DataServer() override;
  explicit constexpr DataServer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataServer(const DataServer& from);
  DataServer(DataServer&& from) noexcept
    : DataServer() {
    *this = ::std::move(from);
  }

  inline DataServer& operator=(const DataServer& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataServer& operator=(DataServer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataServer& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataServer* internal_default_instance() {
    return reinterpret_cast<const DataServer*>(
               &_DataServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DataServer& a, DataServer& b) {
    a.Swap(&b);
  }
  inline void Swap(DataServer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataServer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataServer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataServer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataServer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DataServer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataServer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.DataServer";
  }
  protected:
  explicit DataServer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kPortFieldNumber = 2,
    kStatusFieldNumber = 6,
    kIdcFieldNumber = 7,
    kLastHeartbeatTsFieldNumber = 5,
    kCapacityFieldNumber = 3,
    kFreeFieldNumber = 4,
  };
  // string ip = 1;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // string port = 2;
  void clear_port();
  const std::string& port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable_port();
  PROTOBUF_NODISCARD std::string* release_port();
  void set_allocated_port(std::string* port);
  private:
  const std::string& _internal_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port(const std::string& value);
  std::string* _internal_mutable_port();
  public:

  // string status = 6;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // string idc = 7;
  void clear_idc();
  const std::string& idc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_idc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_idc();
  PROTOBUF_NODISCARD std::string* release_idc();
  void set_allocated_idc(std::string* idc);
  private:
  const std::string& _internal_idc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_idc(const std::string& value);
  std::string* _internal_mutable_idc();
  public:

  // .google.protobuf.Timestamp last_heartbeat_ts = 5;
  bool has_last_heartbeat_ts() const;
  private:
  bool _internal_has_last_heartbeat_ts() const;
  public:
  void clear_last_heartbeat_ts();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_heartbeat_ts() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_heartbeat_ts();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_heartbeat_ts();
  void set_allocated_last_heartbeat_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* last_heartbeat_ts);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_heartbeat_ts() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_heartbeat_ts();
  public:
  void unsafe_arena_set_allocated_last_heartbeat_ts(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_heartbeat_ts);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_heartbeat_ts();

  // uint64 capacity = 3;
  void clear_capacity();
  uint64_t capacity() const;
  void set_capacity(uint64_t value);
  private:
  uint64_t _internal_capacity() const;
  void _internal_set_capacity(uint64_t value);
  public:

  // uint64 free = 4;
  void clear_free();
  uint64_t free() const;
  void set_free(uint64_t value);
  private:
  uint64_t _internal_free() const;
  void _internal_set_free(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.DataServer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr idc_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* last_heartbeat_ts_;
  uint64_t capacity_;
  uint64_t free_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class Replicate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.Replicate) */ {
 public:
  inline Replicate() : Replicate(nullptr) {}
  ~Replicate() override;
  explicit constexpr Replicate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Replicate(const Replicate& from);
  Replicate(Replicate&& from) noexcept
    : Replicate() {
    *this = ::std::move(from);
  }

  inline Replicate& operator=(const Replicate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Replicate& operator=(Replicate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Replicate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Replicate* internal_default_instance() {
    return reinterpret_cast<const Replicate*>(
               &_Replicate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Replicate& a, Replicate& b) {
    a.Swap(&b);
  }
  inline void Swap(Replicate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Replicate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Replicate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Replicate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Replicate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Replicate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Replicate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.Replicate";
  }
  protected:
  explicit Replicate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrsFieldNumber = 1,
  };
  // repeated string addrs = 1;
  int addrs_size() const;
  private:
  int _internal_addrs_size() const;
  public:
  void clear_addrs();
  const std::string& addrs(int index) const;
  std::string* mutable_addrs(int index);
  void set_addrs(int index, const std::string& value);
  void set_addrs(int index, std::string&& value);
  void set_addrs(int index, const char* value);
  void set_addrs(int index, const char* value, size_t size);
  std::string* add_addrs();
  void add_addrs(const std::string& value);
  void add_addrs(std::string&& value);
  void add_addrs(const char* value);
  void add_addrs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& addrs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_addrs();
  private:
  const std::string& _internal_addrs(int index) const;
  std::string* _internal_add_addrs();
  public:

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.Replicate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> addrs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class HeartBeatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.HeartBeatRequest) */ {
 public:
  inline HeartBeatRequest() : HeartBeatRequest(nullptr) {}
  ~HeartBeatRequest() override;
  explicit constexpr HeartBeatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartBeatRequest(const HeartBeatRequest& from);
  HeartBeatRequest(HeartBeatRequest&& from) noexcept
    : HeartBeatRequest() {
    *this = ::std::move(from);
  }

  inline HeartBeatRequest& operator=(const HeartBeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartBeatRequest& operator=(HeartBeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartBeatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartBeatRequest* internal_default_instance() {
    return reinterpret_cast<const HeartBeatRequest*>(
               &_HeartBeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(HeartBeatRequest& a, HeartBeatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartBeatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartBeatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartBeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartBeatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartBeatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HeartBeatRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartBeatRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.HeartBeatRequest";
  }
  protected:
  explicit HeartBeatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
  };
  // string addr = 1;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.HeartBeatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class HeartBeatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.metaserver.HeartBeatResponse) */ {
 public:
  inline HeartBeatResponse() : HeartBeatResponse(nullptr) {}
  explicit constexpr HeartBeatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartBeatResponse(const HeartBeatResponse& from);
  HeartBeatResponse(HeartBeatResponse&& from) noexcept
    : HeartBeatResponse() {
    *this = ::std::move(from);
  }

  inline HeartBeatResponse& operator=(const HeartBeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartBeatResponse& operator=(HeartBeatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartBeatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartBeatResponse* internal_default_instance() {
    return reinterpret_cast<const HeartBeatResponse*>(
               &_HeartBeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(HeartBeatResponse& a, HeartBeatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartBeatResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartBeatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartBeatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartBeatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HeartBeatResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HeartBeatResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.HeartBeatResponse";
  }
  protected:
  explicit HeartBeatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.HeartBeatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class CreateStorageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.CreateStorageRequest) */ {
 public:
  inline CreateStorageRequest() : CreateStorageRequest(nullptr) {}
  ~CreateStorageRequest() override;
  explicit constexpr CreateStorageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateStorageRequest(const CreateStorageRequest& from);
  CreateStorageRequest(CreateStorageRequest&& from) noexcept
    : CreateStorageRequest() {
    *this = ::std::move(from);
  }

  inline CreateStorageRequest& operator=(const CreateStorageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateStorageRequest& operator=(CreateStorageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateStorageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateStorageRequest* internal_default_instance() {
    return reinterpret_cast<const CreateStorageRequest*>(
               &_CreateStorageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CreateStorageRequest& a, CreateStorageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateStorageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateStorageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateStorageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateStorageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateStorageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateStorageRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateStorageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.CreateStorageRequest";
  }
  protected:
  explicit CreateStorageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.CreateStorageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class CreateStorageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.CreateStorageResponse) */ {
 public:
  inline CreateStorageResponse() : CreateStorageResponse(nullptr) {}
  ~CreateStorageResponse() override;
  explicit constexpr CreateStorageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateStorageResponse(const CreateStorageResponse& from);
  CreateStorageResponse(CreateStorageResponse&& from) noexcept
    : CreateStorageResponse() {
    *this = ::std::move(from);
  }

  inline CreateStorageResponse& operator=(const CreateStorageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateStorageResponse& operator=(CreateStorageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateStorageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateStorageResponse* internal_default_instance() {
    return reinterpret_cast<const CreateStorageResponse*>(
               &_CreateStorageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CreateStorageResponse& a, CreateStorageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateStorageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateStorageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateStorageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateStorageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateStorageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateStorageResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateStorageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.CreateStorageResponse";
  }
  protected:
  explicit CreateStorageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.CreateStorageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class CreateShardRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.CreateShardRequest) */ {
 public:
  inline CreateShardRequest() : CreateShardRequest(nullptr) {}
  ~CreateShardRequest() override;
  explicit constexpr CreateShardRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateShardRequest(const CreateShardRequest& from);
  CreateShardRequest(CreateShardRequest&& from) noexcept
    : CreateShardRequest() {
    *this = ::std::move(from);
  }

  inline CreateShardRequest& operator=(const CreateShardRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateShardRequest& operator=(CreateShardRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateShardRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateShardRequest* internal_default_instance() {
    return reinterpret_cast<const CreateShardRequest*>(
               &_CreateShardRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CreateShardRequest& a, CreateShardRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateShardRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateShardRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateShardRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateShardRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateShardRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateShardRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateShardRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.CreateShardRequest";
  }
  protected:
  explicit CreateShardRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShardIdFieldNumber = 1,
    kStorageIdFieldNumber = 2,
  };
  // uint64 shard_id = 1;
  void clear_shard_id();
  uint64_t shard_id() const;
  void set_shard_id(uint64_t value);
  private:
  uint64_t _internal_shard_id() const;
  void _internal_set_shard_id(uint64_t value);
  public:

  // uint64 storage_id = 2;
  void clear_storage_id();
  uint64_t storage_id() const;
  void set_storage_id(uint64_t value);
  private:
  uint64_t _internal_storage_id() const;
  void _internal_set_storage_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.CreateShardRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t shard_id_;
  uint64_t storage_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class CreateShardResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.metaserver.CreateShardResponse) */ {
 public:
  inline CreateShardResponse() : CreateShardResponse(nullptr) {}
  explicit constexpr CreateShardResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateShardResponse(const CreateShardResponse& from);
  CreateShardResponse(CreateShardResponse&& from) noexcept
    : CreateShardResponse() {
    *this = ::std::move(from);
  }

  inline CreateShardResponse& operator=(const CreateShardResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateShardResponse& operator=(CreateShardResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateShardResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateShardResponse* internal_default_instance() {
    return reinterpret_cast<const CreateShardResponse*>(
               &_CreateShardResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CreateShardResponse& a, CreateShardResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateShardResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateShardResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateShardResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateShardResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CreateShardResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CreateShardResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.CreateShardResponse";
  }
  protected:
  explicit CreateShardResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.CreateShardResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class RemoveShardRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.RemoveShardRequest) */ {
 public:
  inline RemoveShardRequest() : RemoveShardRequest(nullptr) {}
  ~RemoveShardRequest() override;
  explicit constexpr RemoveShardRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveShardRequest(const RemoveShardRequest& from);
  RemoveShardRequest(RemoveShardRequest&& from) noexcept
    : RemoveShardRequest() {
    *this = ::std::move(from);
  }

  inline RemoveShardRequest& operator=(const RemoveShardRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveShardRequest& operator=(RemoveShardRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveShardRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveShardRequest* internal_default_instance() {
    return reinterpret_cast<const RemoveShardRequest*>(
               &_RemoveShardRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RemoveShardRequest& a, RemoveShardRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveShardRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveShardRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveShardRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveShardRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveShardRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RemoveShardRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveShardRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.RemoveShardRequest";
  }
  protected:
  explicit RemoveShardRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShardIdFieldNumber = 1,
    kStorageIdFieldNumber = 2,
  };
  // uint64 shard_id = 1;
  void clear_shard_id();
  uint64_t shard_id() const;
  void set_shard_id(uint64_t value);
  private:
  uint64_t _internal_shard_id() const;
  void _internal_set_shard_id(uint64_t value);
  public:

  // uint64 storage_id = 2;
  void clear_storage_id();
  uint64_t storage_id() const;
  void set_storage_id(uint64_t value);
  private:
  uint64_t _internal_storage_id() const;
  void _internal_set_storage_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.RemoveShardRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t shard_id_;
  uint64_t storage_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class RemoveShardResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.metaserver.RemoveShardResponse) */ {
 public:
  inline RemoveShardResponse() : RemoveShardResponse(nullptr) {}
  explicit constexpr RemoveShardResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveShardResponse(const RemoveShardResponse& from);
  RemoveShardResponse(RemoveShardResponse&& from) noexcept
    : RemoveShardResponse() {
    *this = ::std::move(from);
  }

  inline RemoveShardResponse& operator=(const RemoveShardResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveShardResponse& operator=(RemoveShardResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveShardResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveShardResponse* internal_default_instance() {
    return reinterpret_cast<const RemoveShardResponse*>(
               &_RemoveShardResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RemoveShardResponse& a, RemoveShardResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveShardResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveShardResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveShardResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveShardResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RemoveShardResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RemoveShardResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.RemoveShardResponse";
  }
  protected:
  explicit RemoveShardResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.RemoveShardResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class DeleteStorageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.DeleteStorageRequest) */ {
 public:
  inline DeleteStorageRequest() : DeleteStorageRequest(nullptr) {}
  ~DeleteStorageRequest() override;
  explicit constexpr DeleteStorageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteStorageRequest(const DeleteStorageRequest& from);
  DeleteStorageRequest(DeleteStorageRequest&& from) noexcept
    : DeleteStorageRequest() {
    *this = ::std::move(from);
  }

  inline DeleteStorageRequest& operator=(const DeleteStorageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteStorageRequest& operator=(DeleteStorageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteStorageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteStorageRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteStorageRequest*>(
               &_DeleteStorageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DeleteStorageRequest& a, DeleteStorageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteStorageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteStorageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteStorageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteStorageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteStorageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteStorageRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteStorageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.DeleteStorageRequest";
  }
  protected:
  explicit DeleteStorageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kRecycleAfterFieldNumber = 3,
    kRealDeleteFieldNumber = 2,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // uint64 recycle_after = 3;
  void clear_recycle_after();
  uint64_t recycle_after() const;
  void set_recycle_after(uint64_t value);
  private:
  uint64_t _internal_recycle_after() const;
  void _internal_set_recycle_after(uint64_t value);
  public:

  // bool real_delete = 2;
  void clear_real_delete();
  bool real_delete() const;
  void set_real_delete(bool value);
  private:
  bool _internal_real_delete() const;
  void _internal_set_real_delete(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.DeleteStorageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t id_;
  uint64_t recycle_after_;
  bool real_delete_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class DeleteStorageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.metaserver.DeleteStorageResponse) */ {
 public:
  inline DeleteStorageResponse() : DeleteStorageResponse(nullptr) {}
  explicit constexpr DeleteStorageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteStorageResponse(const DeleteStorageResponse& from);
  DeleteStorageResponse(DeleteStorageResponse&& from) noexcept
    : DeleteStorageResponse() {
    *this = ::std::move(from);
  }

  inline DeleteStorageResponse& operator=(const DeleteStorageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteStorageResponse& operator=(DeleteStorageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteStorageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteStorageResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteStorageResponse*>(
               &_DeleteStorageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DeleteStorageResponse& a, DeleteStorageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteStorageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteStorageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteStorageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteStorageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteStorageResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteStorageResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.DeleteStorageResponse";
  }
  protected:
  explicit DeleteStorageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.DeleteStorageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class UndeleteStorageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.UndeleteStorageRequest) */ {
 public:
  inline UndeleteStorageRequest() : UndeleteStorageRequest(nullptr) {}
  ~UndeleteStorageRequest() override;
  explicit constexpr UndeleteStorageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UndeleteStorageRequest(const UndeleteStorageRequest& from);
  UndeleteStorageRequest(UndeleteStorageRequest&& from) noexcept
    : UndeleteStorageRequest() {
    *this = ::std::move(from);
  }

  inline UndeleteStorageRequest& operator=(const UndeleteStorageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UndeleteStorageRequest& operator=(UndeleteStorageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UndeleteStorageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UndeleteStorageRequest* internal_default_instance() {
    return reinterpret_cast<const UndeleteStorageRequest*>(
               &_UndeleteStorageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UndeleteStorageRequest& a, UndeleteStorageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UndeleteStorageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UndeleteStorageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UndeleteStorageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UndeleteStorageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UndeleteStorageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UndeleteStorageRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UndeleteStorageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.UndeleteStorageRequest";
  }
  protected:
  explicit UndeleteStorageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.UndeleteStorageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class UndeleteStorageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.metaserver.UndeleteStorageResponse) */ {
 public:
  inline UndeleteStorageResponse() : UndeleteStorageResponse(nullptr) {}
  explicit constexpr UndeleteStorageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UndeleteStorageResponse(const UndeleteStorageResponse& from);
  UndeleteStorageResponse(UndeleteStorageResponse&& from) noexcept
    : UndeleteStorageResponse() {
    *this = ::std::move(from);
  }

  inline UndeleteStorageResponse& operator=(const UndeleteStorageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UndeleteStorageResponse& operator=(UndeleteStorageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UndeleteStorageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UndeleteStorageResponse* internal_default_instance() {
    return reinterpret_cast<const UndeleteStorageResponse*>(
               &_UndeleteStorageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UndeleteStorageResponse& a, UndeleteStorageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UndeleteStorageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UndeleteStorageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UndeleteStorageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UndeleteStorageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UndeleteStorageResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UndeleteStorageResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.UndeleteStorageResponse";
  }
  protected:
  explicit UndeleteStorageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.UndeleteStorageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class RenameStorageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.RenameStorageRequest) */ {
 public:
  inline RenameStorageRequest() : RenameStorageRequest(nullptr) {}
  ~RenameStorageRequest() override;
  explicit constexpr RenameStorageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenameStorageRequest(const RenameStorageRequest& from);
  RenameStorageRequest(RenameStorageRequest&& from) noexcept
    : RenameStorageRequest() {
    *this = ::std::move(from);
  }

  inline RenameStorageRequest& operator=(const RenameStorageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenameStorageRequest& operator=(RenameStorageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenameStorageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenameStorageRequest* internal_default_instance() {
    return reinterpret_cast<const RenameStorageRequest*>(
               &_RenameStorageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RenameStorageRequest& a, RenameStorageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RenameStorageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenameStorageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenameStorageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RenameStorageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RenameStorageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RenameStorageRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RenameStorageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.RenameStorageRequest";
  }
  protected:
  explicit RenameStorageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewNameFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string new_name = 2;
  void clear_new_name();
  const std::string& new_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_name();
  PROTOBUF_NODISCARD std::string* release_new_name();
  void set_allocated_new_name(std::string* new_name);
  private:
  const std::string& _internal_new_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_name(const std::string& value);
  std::string* _internal_mutable_new_name();
  public:

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.RenameStorageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_name_;
  uint64_t id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class RenameStorageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.metaserver.RenameStorageResponse) */ {
 public:
  inline RenameStorageResponse() : RenameStorageResponse(nullptr) {}
  explicit constexpr RenameStorageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenameStorageResponse(const RenameStorageResponse& from);
  RenameStorageResponse(RenameStorageResponse&& from) noexcept
    : RenameStorageResponse() {
    *this = ::std::move(from);
  }

  inline RenameStorageResponse& operator=(const RenameStorageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenameStorageResponse& operator=(RenameStorageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenameStorageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenameStorageResponse* internal_default_instance() {
    return reinterpret_cast<const RenameStorageResponse*>(
               &_RenameStorageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RenameStorageResponse& a, RenameStorageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RenameStorageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenameStorageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenameStorageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RenameStorageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RenameStorageResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RenameStorageResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.RenameStorageResponse";
  }
  protected:
  explicit RenameStorageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.RenameStorageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class ResizeStorageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.ResizeStorageRequest) */ {
 public:
  inline ResizeStorageRequest() : ResizeStorageRequest(nullptr) {}
  ~ResizeStorageRequest() override;
  explicit constexpr ResizeStorageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResizeStorageRequest(const ResizeStorageRequest& from);
  ResizeStorageRequest(ResizeStorageRequest&& from) noexcept
    : ResizeStorageRequest() {
    *this = ::std::move(from);
  }

  inline ResizeStorageRequest& operator=(const ResizeStorageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResizeStorageRequest& operator=(ResizeStorageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResizeStorageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResizeStorageRequest* internal_default_instance() {
    return reinterpret_cast<const ResizeStorageRequest*>(
               &_ResizeStorageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ResizeStorageRequest& a, ResizeStorageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ResizeStorageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResizeStorageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResizeStorageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResizeStorageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResizeStorageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResizeStorageRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResizeStorageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.ResizeStorageRequest";
  }
  protected:
  explicit ResizeStorageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNewSizeFieldNumber = 2,
    kNewShardCountFieldNumber = 3,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // uint64 new_size = 2;
  void clear_new_size();
  uint64_t new_size() const;
  void set_new_size(uint64_t value);
  private:
  uint64_t _internal_new_size() const;
  void _internal_set_new_size(uint64_t value);
  public:

  // uint64 new_shard_count = 3;
  void clear_new_shard_count();
  uint64_t new_shard_count() const;
  void set_new_shard_count(uint64_t value);
  private:
  uint64_t _internal_new_shard_count() const;
  void _internal_set_new_shard_count(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.ResizeStorageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t id_;
  uint64_t new_size_;
  uint64_t new_shard_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class ResizeStorageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.metaserver.ResizeStorageResponse) */ {
 public:
  inline ResizeStorageResponse() : ResizeStorageResponse(nullptr) {}
  explicit constexpr ResizeStorageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResizeStorageResponse(const ResizeStorageResponse& from);
  ResizeStorageResponse(ResizeStorageResponse&& from) noexcept
    : ResizeStorageResponse() {
    *this = ::std::move(from);
  }

  inline ResizeStorageResponse& operator=(const ResizeStorageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResizeStorageResponse& operator=(ResizeStorageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResizeStorageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResizeStorageResponse* internal_default_instance() {
    return reinterpret_cast<const ResizeStorageResponse*>(
               &_ResizeStorageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ResizeStorageResponse& a, ResizeStorageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ResizeStorageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResizeStorageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResizeStorageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResizeStorageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResizeStorageResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResizeStorageResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.ResizeStorageResponse";
  }
  protected:
  explicit ResizeStorageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.ResizeStorageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class GetStoragesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.GetStoragesRequest) */ {
 public:
  inline GetStoragesRequest() : GetStoragesRequest(nullptr) {}
  ~GetStoragesRequest() override;
  explicit constexpr GetStoragesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStoragesRequest(const GetStoragesRequest& from);
  GetStoragesRequest(GetStoragesRequest&& from) noexcept
    : GetStoragesRequest() {
    *this = ::std::move(from);
  }

  inline GetStoragesRequest& operator=(const GetStoragesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStoragesRequest& operator=(GetStoragesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStoragesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStoragesRequest* internal_default_instance() {
    return reinterpret_cast<const GetStoragesRequest*>(
               &_GetStoragesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GetStoragesRequest& a, GetStoragesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStoragesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStoragesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStoragesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetStoragesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetStoragesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetStoragesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStoragesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.GetStoragesRequest";
  }
  protected:
  explicit GetStoragesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdsFieldNumber = 1,
    kNamesFieldNumber = 2,
  };
  // repeated uint64 ids = 1;
  int ids_size() const;
  private:
  int _internal_ids_size() const;
  public:
  void clear_ids();
  private:
  uint64_t _internal_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_ids() const;
  void _internal_add_ids(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_ids();
  public:
  uint64_t ids(int index) const;
  void set_ids(int index, uint64_t value);
  void add_ids(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_ids();

  // repeated string names = 2;
  int names_size() const;
  private:
  int _internal_names_size() const;
  public:
  void clear_names();
  const std::string& names(int index) const;
  std::string* mutable_names(int index);
  void set_names(int index, const std::string& value);
  void set_names(int index, std::string&& value);
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, size_t size);
  std::string* add_names();
  void add_names(const std::string& value);
  void add_names(std::string&& value);
  void add_names(const char* value);
  void add_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_names();
  private:
  const std::string& _internal_names(int index) const;
  std::string* _internal_add_names();
  public:

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.GetStoragesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > ids_;
  mutable std::atomic<int> _ids_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> names_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class GetStoragesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.GetStoragesResponse) */ {
 public:
  inline GetStoragesResponse() : GetStoragesResponse(nullptr) {}
  ~GetStoragesResponse() override;
  explicit constexpr GetStoragesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStoragesResponse(const GetStoragesResponse& from);
  GetStoragesResponse(GetStoragesResponse&& from) noexcept
    : GetStoragesResponse() {
    *this = ::std::move(from);
  }

  inline GetStoragesResponse& operator=(const GetStoragesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStoragesResponse& operator=(GetStoragesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStoragesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStoragesResponse* internal_default_instance() {
    return reinterpret_cast<const GetStoragesResponse*>(
               &_GetStoragesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GetStoragesResponse& a, GetStoragesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStoragesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStoragesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStoragesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetStoragesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetStoragesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetStoragesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStoragesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.GetStoragesResponse";
  }
  protected:
  explicit GetStoragesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoragesFieldNumber = 1,
  };
  // repeated .bedrock.metaserver.Storage storages = 1;
  int storages_size() const;
  private:
  int _internal_storages_size() const;
  public:
  void clear_storages();
  ::bedrock::metaserver::Storage* mutable_storages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bedrock::metaserver::Storage >*
      mutable_storages();
  private:
  const ::bedrock::metaserver::Storage& _internal_storages(int index) const;
  ::bedrock::metaserver::Storage* _internal_add_storages();
  public:
  const ::bedrock::metaserver::Storage& storages(int index) const;
  ::bedrock::metaserver::Storage* add_storages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bedrock::metaserver::Storage >&
      storages() const;

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.GetStoragesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bedrock::metaserver::Storage > storages_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class ShardRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.ShardRange) */ {
 public:
  inline ShardRange() : ShardRange(nullptr) {}
  ~ShardRange() override;
  explicit constexpr ShardRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShardRange(const ShardRange& from);
  ShardRange(ShardRange&& from) noexcept
    : ShardRange() {
    *this = ::std::move(from);
  }

  inline ShardRange& operator=(const ShardRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardRange& operator=(ShardRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShardRange* internal_default_instance() {
    return reinterpret_cast<const ShardRange*>(
               &_ShardRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ShardRange& a, ShardRange& b) {
    a.Swap(&b);
  }
  inline void Swap(ShardRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShardRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShardRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShardRange& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShardRange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.ShardRange";
  }
  protected:
  explicit ShardRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartShardIdFieldNumber = 1,
    kOffsetFieldNumber = 2,
  };
  // uint64 start_shard_id = 1;
  void clear_start_shard_id();
  uint64_t start_shard_id() const;
  void set_start_shard_id(uint64_t value);
  private:
  uint64_t _internal_start_shard_id() const;
  void _internal_set_start_shard_id(uint64_t value);
  public:

  // uint64 offset = 2;
  void clear_offset();
  uint64_t offset() const;
  void set_offset(uint64_t value);
  private:
  uint64_t _internal_offset() const;
  void _internal_set_offset(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.ShardRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t start_shard_id_;
  uint64_t offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class RouteRecord final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.RouteRecord) */ {
 public:
  inline RouteRecord() : RouteRecord(nullptr) {}
  ~RouteRecord() override;
  explicit constexpr RouteRecord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteRecord(const RouteRecord& from);
  RouteRecord(RouteRecord&& from) noexcept
    : RouteRecord() {
    *this = ::std::move(from);
  }

  inline RouteRecord& operator=(const RouteRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteRecord& operator=(RouteRecord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteRecord& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteRecord* internal_default_instance() {
    return reinterpret_cast<const RouteRecord*>(
               &_RouteRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(RouteRecord& a, RouteRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteRecord* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteRecord* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouteRecord>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteRecord& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouteRecord& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteRecord* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.RouteRecord";
  }
  protected:
  explicit RouteRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrsFieldNumber = 2,
    kShardIdFieldNumber = 1,
  };
  // repeated string addrs = 2;
  int addrs_size() const;
  private:
  int _internal_addrs_size() const;
  public:
  void clear_addrs();
  const std::string& addrs(int index) const;
  std::string* mutable_addrs(int index);
  void set_addrs(int index, const std::string& value);
  void set_addrs(int index, std::string&& value);
  void set_addrs(int index, const char* value);
  void set_addrs(int index, const char* value, size_t size);
  std::string* add_addrs();
  void add_addrs(const std::string& value);
  void add_addrs(std::string&& value);
  void add_addrs(const char* value);
  void add_addrs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& addrs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_addrs();
  private:
  const std::string& _internal_addrs(int index) const;
  std::string* _internal_add_addrs();
  public:

  // uint64 shard_id = 1;
  void clear_shard_id();
  uint64_t shard_id() const;
  void set_shard_id(uint64_t value);
  private:
  uint64_t _internal_shard_id() const;
  void _internal_set_shard_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.RouteRecord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> addrs_;
  uint64_t shard_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class ShardList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.ShardList) */ {
 public:
  inline ShardList() : ShardList(nullptr) {}
  ~ShardList() override;
  explicit constexpr ShardList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShardList(const ShardList& from);
  ShardList(ShardList&& from) noexcept
    : ShardList() {
    *this = ::std::move(from);
  }

  inline ShardList& operator=(const ShardList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardList& operator=(ShardList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShardList* internal_default_instance() {
    return reinterpret_cast<const ShardList*>(
               &_ShardList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ShardList& a, ShardList& b) {
    a.Swap(&b);
  }
  inline void Swap(ShardList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShardList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShardList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShardList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShardList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.ShardList";
  }
  protected:
  explicit ShardList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShardIdsFieldNumber = 1,
  };
  // repeated uint64 shard_ids = 1;
  int shard_ids_size() const;
  private:
  int _internal_shard_ids_size() const;
  public:
  void clear_shard_ids();
  private:
  uint64_t _internal_shard_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_shard_ids() const;
  void _internal_add_shard_ids(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_shard_ids();
  public:
  uint64_t shard_ids(int index) const;
  void set_shard_ids(int index, uint64_t value);
  void add_shard_ids(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      shard_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_shard_ids();

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.ShardList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > shard_ids_;
  mutable std::atomic<int> _shard_ids_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class GetShardRoutesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.GetShardRoutesRequest) */ {
 public:
  inline GetShardRoutesRequest() : GetShardRoutesRequest(nullptr) {}
  ~GetShardRoutesRequest() override;
  explicit constexpr GetShardRoutesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetShardRoutesRequest(const GetShardRoutesRequest& from);
  GetShardRoutesRequest(GetShardRoutesRequest&& from) noexcept
    : GetShardRoutesRequest() {
    *this = ::std::move(from);
  }

  inline GetShardRoutesRequest& operator=(const GetShardRoutesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetShardRoutesRequest& operator=(GetShardRoutesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetShardRoutesRequest& default_instance() {
    return *internal_default_instance();
  }
  enum ShardsCase {
    kShardsList = 1,
    kShardRange = 2,
    SHARDS_NOT_SET = 0,
  };

  static inline const GetShardRoutesRequest* internal_default_instance() {
    return reinterpret_cast<const GetShardRoutesRequest*>(
               &_GetShardRoutesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(GetShardRoutesRequest& a, GetShardRoutesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetShardRoutesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetShardRoutesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetShardRoutesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetShardRoutesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetShardRoutesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetShardRoutesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetShardRoutesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.GetShardRoutesRequest";
  }
  protected:
  explicit GetShardRoutesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 3,
    kShardsListFieldNumber = 1,
    kShardRangeFieldNumber = 2,
  };
  // .google.protobuf.Timestamp timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .bedrock.metaserver.ShardList shards_list = 1;
  bool has_shards_list() const;
  private:
  bool _internal_has_shards_list() const;
  public:
  void clear_shards_list();
  const ::bedrock::metaserver::ShardList& shards_list() const;
  PROTOBUF_NODISCARD ::bedrock::metaserver::ShardList* release_shards_list();
  ::bedrock::metaserver::ShardList* mutable_shards_list();
  void set_allocated_shards_list(::bedrock::metaserver::ShardList* shards_list);
  private:
  const ::bedrock::metaserver::ShardList& _internal_shards_list() const;
  ::bedrock::metaserver::ShardList* _internal_mutable_shards_list();
  public:
  void unsafe_arena_set_allocated_shards_list(
      ::bedrock::metaserver::ShardList* shards_list);
  ::bedrock::metaserver::ShardList* unsafe_arena_release_shards_list();

  // .bedrock.metaserver.ShardRange shard_range = 2;
  bool has_shard_range() const;
  private:
  bool _internal_has_shard_range() const;
  public:
  void clear_shard_range();
  const ::bedrock::metaserver::ShardRange& shard_range() const;
  PROTOBUF_NODISCARD ::bedrock::metaserver::ShardRange* release_shard_range();
  ::bedrock::metaserver::ShardRange* mutable_shard_range();
  void set_allocated_shard_range(::bedrock::metaserver::ShardRange* shard_range);
  private:
  const ::bedrock::metaserver::ShardRange& _internal_shard_range() const;
  ::bedrock::metaserver::ShardRange* _internal_mutable_shard_range();
  public:
  void unsafe_arena_set_allocated_shard_range(
      ::bedrock::metaserver::ShardRange* shard_range);
  ::bedrock::metaserver::ShardRange* unsafe_arena_release_shard_range();

  void clear_shards();
  ShardsCase shards_case() const;
  // @@protoc_insertion_point(class_scope:bedrock.metaserver.GetShardRoutesRequest)
 private:
  class _Internal;
  void set_has_shards_list();
  void set_has_shard_range();

  inline bool has_shards() const;
  inline void clear_has_shards();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  union ShardsUnion {
    constexpr ShardsUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::bedrock::metaserver::ShardList* shards_list_;
    ::bedrock::metaserver::ShardRange* shard_range_;
  } shards_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class GetShardRoutesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.GetShardRoutesResponse) */ {
 public:
  inline GetShardRoutesResponse() : GetShardRoutesResponse(nullptr) {}
  ~GetShardRoutesResponse() override;
  explicit constexpr GetShardRoutesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetShardRoutesResponse(const GetShardRoutesResponse& from);
  GetShardRoutesResponse(GetShardRoutesResponse&& from) noexcept
    : GetShardRoutesResponse() {
    *this = ::std::move(from);
  }

  inline GetShardRoutesResponse& operator=(const GetShardRoutesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetShardRoutesResponse& operator=(GetShardRoutesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetShardRoutesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetShardRoutesResponse* internal_default_instance() {
    return reinterpret_cast<const GetShardRoutesResponse*>(
               &_GetShardRoutesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GetShardRoutesResponse& a, GetShardRoutesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetShardRoutesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetShardRoutesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetShardRoutesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetShardRoutesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetShardRoutesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetShardRoutesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetShardRoutesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.GetShardRoutesResponse";
  }
  protected:
  explicit GetShardRoutesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoutesFieldNumber = 1,
  };
  // repeated .bedrock.metaserver.RouteRecord routes = 1;
  int routes_size() const;
  private:
  int _internal_routes_size() const;
  public:
  void clear_routes();
  ::bedrock::metaserver::RouteRecord* mutable_routes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bedrock::metaserver::RouteRecord >*
      mutable_routes();
  private:
  const ::bedrock::metaserver::RouteRecord& _internal_routes(int index) const;
  ::bedrock::metaserver::RouteRecord* _internal_add_routes();
  public:
  const ::bedrock::metaserver::RouteRecord& routes(int index) const;
  ::bedrock::metaserver::RouteRecord* add_routes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bedrock::metaserver::RouteRecord >&
      routes() const;

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.GetShardRoutesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bedrock::metaserver::RouteRecord > routes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class GetShardRoutesByStorageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.GetShardRoutesByStorageRequest) */ {
 public:
  inline GetShardRoutesByStorageRequest() : GetShardRoutesByStorageRequest(nullptr) {}
  ~GetShardRoutesByStorageRequest() override;
  explicit constexpr GetShardRoutesByStorageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetShardRoutesByStorageRequest(const GetShardRoutesByStorageRequest& from);
  GetShardRoutesByStorageRequest(GetShardRoutesByStorageRequest&& from) noexcept
    : GetShardRoutesByStorageRequest() {
    *this = ::std::move(from);
  }

  inline GetShardRoutesByStorageRequest& operator=(const GetShardRoutesByStorageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetShardRoutesByStorageRequest& operator=(GetShardRoutesByStorageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetShardRoutesByStorageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetShardRoutesByStorageRequest* internal_default_instance() {
    return reinterpret_cast<const GetShardRoutesByStorageRequest*>(
               &_GetShardRoutesByStorageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(GetShardRoutesByStorageRequest& a, GetShardRoutesByStorageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetShardRoutesByStorageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetShardRoutesByStorageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetShardRoutesByStorageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetShardRoutesByStorageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetShardRoutesByStorageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetShardRoutesByStorageRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetShardRoutesByStorageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.GetShardRoutesByStorageRequest";
  }
  protected:
  explicit GetShardRoutesByStorageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 2,
    kStorageIdFieldNumber = 1,
  };
  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // uint64 storage_id = 1;
  void clear_storage_id();
  uint64_t storage_id() const;
  void set_storage_id(uint64_t value);
  private:
  uint64_t _internal_storage_id() const;
  void _internal_set_storage_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.GetShardRoutesByStorageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  uint64_t storage_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class GetShardRoutesByStorageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.GetShardRoutesByStorageResponse) */ {
 public:
  inline GetShardRoutesByStorageResponse() : GetShardRoutesByStorageResponse(nullptr) {}
  ~GetShardRoutesByStorageResponse() override;
  explicit constexpr GetShardRoutesByStorageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetShardRoutesByStorageResponse(const GetShardRoutesByStorageResponse& from);
  GetShardRoutesByStorageResponse(GetShardRoutesByStorageResponse&& from) noexcept
    : GetShardRoutesByStorageResponse() {
    *this = ::std::move(from);
  }

  inline GetShardRoutesByStorageResponse& operator=(const GetShardRoutesByStorageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetShardRoutesByStorageResponse& operator=(GetShardRoutesByStorageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetShardRoutesByStorageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetShardRoutesByStorageResponse* internal_default_instance() {
    return reinterpret_cast<const GetShardRoutesByStorageResponse*>(
               &_GetShardRoutesByStorageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(GetShardRoutesByStorageResponse& a, GetShardRoutesByStorageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetShardRoutesByStorageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetShardRoutesByStorageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetShardRoutesByStorageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetShardRoutesByStorageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetShardRoutesByStorageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetShardRoutesByStorageResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetShardRoutesByStorageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.GetShardRoutesByStorageResponse";
  }
  protected:
  explicit GetShardRoutesByStorageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoutesFieldNumber = 1,
    kTimestampFieldNumber = 2,
    kIsFullFieldNumber = 3,
  };
  // repeated .bedrock.metaserver.RouteRecord routes = 1;
  int routes_size() const;
  private:
  int _internal_routes_size() const;
  public:
  void clear_routes();
  ::bedrock::metaserver::RouteRecord* mutable_routes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bedrock::metaserver::RouteRecord >*
      mutable_routes();
  private:
  const ::bedrock::metaserver::RouteRecord& _internal_routes(int index) const;
  ::bedrock::metaserver::RouteRecord* _internal_add_routes();
  public:
  const ::bedrock::metaserver::RouteRecord& routes(int index) const;
  ::bedrock::metaserver::RouteRecord* add_routes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bedrock::metaserver::RouteRecord >&
      routes() const;

  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // bool is_full = 3;
  void clear_is_full();
  bool is_full() const;
  void set_is_full(bool value);
  private:
  bool _internal_is_full() const;
  void _internal_set_is_full(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.GetShardRoutesByStorageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bedrock::metaserver::RouteRecord > routes_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  bool is_full_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class AddDataServerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.AddDataServerRequest) */ {
 public:
  inline AddDataServerRequest() : AddDataServerRequest(nullptr) {}
  ~AddDataServerRequest() override;
  explicit constexpr AddDataServerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddDataServerRequest(const AddDataServerRequest& from);
  AddDataServerRequest(AddDataServerRequest&& from) noexcept
    : AddDataServerRequest() {
    *this = ::std::move(from);
  }

  inline AddDataServerRequest& operator=(const AddDataServerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddDataServerRequest& operator=(AddDataServerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddDataServerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddDataServerRequest* internal_default_instance() {
    return reinterpret_cast<const AddDataServerRequest*>(
               &_AddDataServerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(AddDataServerRequest& a, AddDataServerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddDataServerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddDataServerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddDataServerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddDataServerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddDataServerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddDataServerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddDataServerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.AddDataServerRequest";
  }
  protected:
  explicit AddDataServerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
  };
  // string addr = 1;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.AddDataServerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class AddDataServerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.metaserver.AddDataServerResponse) */ {
 public:
  inline AddDataServerResponse() : AddDataServerResponse(nullptr) {}
  explicit constexpr AddDataServerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddDataServerResponse(const AddDataServerResponse& from);
  AddDataServerResponse(AddDataServerResponse&& from) noexcept
    : AddDataServerResponse() {
    *this = ::std::move(from);
  }

  inline AddDataServerResponse& operator=(const AddDataServerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddDataServerResponse& operator=(AddDataServerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddDataServerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddDataServerResponse* internal_default_instance() {
    return reinterpret_cast<const AddDataServerResponse*>(
               &_AddDataServerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(AddDataServerResponse& a, AddDataServerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AddDataServerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddDataServerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddDataServerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddDataServerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AddDataServerResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AddDataServerResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.AddDataServerResponse";
  }
  protected:
  explicit AddDataServerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.AddDataServerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class RemoveDataServerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.RemoveDataServerRequest) */ {
 public:
  inline RemoveDataServerRequest() : RemoveDataServerRequest(nullptr) {}
  ~RemoveDataServerRequest() override;
  explicit constexpr RemoveDataServerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveDataServerRequest(const RemoveDataServerRequest& from);
  RemoveDataServerRequest(RemoveDataServerRequest&& from) noexcept
    : RemoveDataServerRequest() {
    *this = ::std::move(from);
  }

  inline RemoveDataServerRequest& operator=(const RemoveDataServerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveDataServerRequest& operator=(RemoveDataServerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveDataServerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveDataServerRequest* internal_default_instance() {
    return reinterpret_cast<const RemoveDataServerRequest*>(
               &_RemoveDataServerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(RemoveDataServerRequest& a, RemoveDataServerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveDataServerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveDataServerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveDataServerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveDataServerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveDataServerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RemoveDataServerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveDataServerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.RemoveDataServerRequest";
  }
  protected:
  explicit RemoveDataServerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
  };
  // string addr = 1;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.RemoveDataServerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class RemoveDataServerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.metaserver.RemoveDataServerResponse) */ {
 public:
  inline RemoveDataServerResponse() : RemoveDataServerResponse(nullptr) {}
  explicit constexpr RemoveDataServerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveDataServerResponse(const RemoveDataServerResponse& from);
  RemoveDataServerResponse(RemoveDataServerResponse&& from) noexcept
    : RemoveDataServerResponse() {
    *this = ::std::move(from);
  }

  inline RemoveDataServerResponse& operator=(const RemoveDataServerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveDataServerResponse& operator=(RemoveDataServerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveDataServerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveDataServerResponse* internal_default_instance() {
    return reinterpret_cast<const RemoveDataServerResponse*>(
               &_RemoveDataServerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(RemoveDataServerResponse& a, RemoveDataServerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveDataServerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveDataServerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveDataServerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveDataServerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RemoveDataServerResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RemoveDataServerResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.RemoveDataServerResponse";
  }
  protected:
  explicit RemoveDataServerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.RemoveDataServerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class ListDataServerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.metaserver.ListDataServerRequest) */ {
 public:
  inline ListDataServerRequest() : ListDataServerRequest(nullptr) {}
  explicit constexpr ListDataServerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListDataServerRequest(const ListDataServerRequest& from);
  ListDataServerRequest(ListDataServerRequest&& from) noexcept
    : ListDataServerRequest() {
    *this = ::std::move(from);
  }

  inline ListDataServerRequest& operator=(const ListDataServerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDataServerRequest& operator=(ListDataServerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDataServerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListDataServerRequest* internal_default_instance() {
    return reinterpret_cast<const ListDataServerRequest*>(
               &_ListDataServerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ListDataServerRequest& a, ListDataServerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListDataServerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDataServerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListDataServerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListDataServerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ListDataServerRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ListDataServerRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.ListDataServerRequest";
  }
  protected:
  explicit ListDataServerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.ListDataServerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class ListDataServerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.ListDataServerResponse) */ {
 public:
  inline ListDataServerResponse() : ListDataServerResponse(nullptr) {}
  ~ListDataServerResponse() override;
  explicit constexpr ListDataServerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListDataServerResponse(const ListDataServerResponse& from);
  ListDataServerResponse(ListDataServerResponse&& from) noexcept
    : ListDataServerResponse() {
    *this = ::std::move(from);
  }

  inline ListDataServerResponse& operator=(const ListDataServerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDataServerResponse& operator=(ListDataServerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDataServerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListDataServerResponse* internal_default_instance() {
    return reinterpret_cast<const ListDataServerResponse*>(
               &_ListDataServerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ListDataServerResponse& a, ListDataServerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListDataServerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDataServerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListDataServerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListDataServerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListDataServerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListDataServerResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListDataServerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.ListDataServerResponse";
  }
  protected:
  explicit ListDataServerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataServersFieldNumber = 1,
  };
  // repeated .bedrock.metaserver.DataServer data_servers = 1;
  int data_servers_size() const;
  private:
  int _internal_data_servers_size() const;
  public:
  void clear_data_servers();
  ::bedrock::metaserver::DataServer* mutable_data_servers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bedrock::metaserver::DataServer >*
      mutable_data_servers();
  private:
  const ::bedrock::metaserver::DataServer& _internal_data_servers(int index) const;
  ::bedrock::metaserver::DataServer* _internal_add_data_servers();
  public:
  const ::bedrock::metaserver::DataServer& data_servers(int index) const;
  ::bedrock::metaserver::DataServer* add_data_servers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bedrock::metaserver::DataServer >&
      data_servers() const;

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.ListDataServerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bedrock::metaserver::DataServer > data_servers_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class UpdateDataServerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.metaserver.UpdateDataServerRequest) */ {
 public:
  inline UpdateDataServerRequest() : UpdateDataServerRequest(nullptr) {}
  explicit constexpr UpdateDataServerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateDataServerRequest(const UpdateDataServerRequest& from);
  UpdateDataServerRequest(UpdateDataServerRequest&& from) noexcept
    : UpdateDataServerRequest() {
    *this = ::std::move(from);
  }

  inline UpdateDataServerRequest& operator=(const UpdateDataServerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateDataServerRequest& operator=(UpdateDataServerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateDataServerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateDataServerRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateDataServerRequest*>(
               &_UpdateDataServerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(UpdateDataServerRequest& a, UpdateDataServerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateDataServerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateDataServerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateDataServerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateDataServerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateDataServerRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateDataServerRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.UpdateDataServerRequest";
  }
  protected:
  explicit UpdateDataServerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.UpdateDataServerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class UpdateDataServerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.metaserver.UpdateDataServerResponse) */ {
 public:
  inline UpdateDataServerResponse() : UpdateDataServerResponse(nullptr) {}
  explicit constexpr UpdateDataServerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateDataServerResponse(const UpdateDataServerResponse& from);
  UpdateDataServerResponse(UpdateDataServerResponse&& from) noexcept
    : UpdateDataServerResponse() {
    *this = ::std::move(from);
  }

  inline UpdateDataServerResponse& operator=(const UpdateDataServerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateDataServerResponse& operator=(UpdateDataServerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateDataServerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateDataServerResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateDataServerResponse*>(
               &_UpdateDataServerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(UpdateDataServerResponse& a, UpdateDataServerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateDataServerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateDataServerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateDataServerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateDataServerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateDataServerResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateDataServerResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.UpdateDataServerResponse";
  }
  protected:
  explicit UpdateDataServerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.UpdateDataServerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class ShardInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.ShardInfoRequest) */ {
 public:
  inline ShardInfoRequest() : ShardInfoRequest(nullptr) {}
  ~ShardInfoRequest() override;
  explicit constexpr ShardInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShardInfoRequest(const ShardInfoRequest& from);
  ShardInfoRequest(ShardInfoRequest&& from) noexcept
    : ShardInfoRequest() {
    *this = ::std::move(from);
  }

  inline ShardInfoRequest& operator=(const ShardInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardInfoRequest& operator=(ShardInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShardInfoRequest* internal_default_instance() {
    return reinterpret_cast<const ShardInfoRequest*>(
               &_ShardInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(ShardInfoRequest& a, ShardInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ShardInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShardInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShardInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShardInfoRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShardInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.ShardInfoRequest";
  }
  protected:
  explicit ShardInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.ShardInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// -------------------------------------------------------------------

class ShardInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.metaserver.ShardInfoResponse) */ {
 public:
  inline ShardInfoResponse() : ShardInfoResponse(nullptr) {}
  ~ShardInfoResponse() override;
  explicit constexpr ShardInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShardInfoResponse(const ShardInfoResponse& from);
  ShardInfoResponse(ShardInfoResponse&& from) noexcept
    : ShardInfoResponse() {
    *this = ::std::move(from);
  }

  inline ShardInfoResponse& operator=(const ShardInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardInfoResponse& operator=(ShardInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShardInfoResponse* internal_default_instance() {
    return reinterpret_cast<const ShardInfoResponse*>(
               &_ShardInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(ShardInfoResponse& a, ShardInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ShardInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShardInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShardInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShardInfoResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShardInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.metaserver.ShardInfoResponse";
  }
  protected:
  explicit ShardInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShardFieldNumber = 1,
  };
  // .bedrock.metaserver.Shard shard = 1;
  bool has_shard() const;
  private:
  bool _internal_has_shard() const;
  public:
  void clear_shard();
  const ::bedrock::metaserver::Shard& shard() const;
  PROTOBUF_NODISCARD ::bedrock::metaserver::Shard* release_shard();
  ::bedrock::metaserver::Shard* mutable_shard();
  void set_allocated_shard(::bedrock::metaserver::Shard* shard);
  private:
  const ::bedrock::metaserver::Shard& _internal_shard() const;
  ::bedrock::metaserver::Shard* _internal_mutable_shard();
  public:
  void unsafe_arena_set_allocated_shard(
      ::bedrock::metaserver::Shard* shard);
  ::bedrock::metaserver::Shard* unsafe_arena_release_shard();

  // @@protoc_insertion_point(class_scope:bedrock.metaserver.ShardInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bedrock::metaserver::Shard* shard_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metaserver_2eproto;
};
// ===================================================================

class MetaService_Stub;

class MetaService : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline MetaService() {};
 public:
  virtual ~MetaService();

  typedef MetaService_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void HeartBeat(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::HeartBeatRequest* request,
                       ::PROTOBUF_NAMESPACE_ID::Empty* response,
                       ::google::protobuf::Closure* done);
  virtual void GetShardRoutes(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::GetShardRoutesRequest* request,
                       ::bedrock::metaserver::GetShardRoutesResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void ShardInfo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::ShardInfoRequest* request,
                       ::bedrock::metaserver::ShardInfoResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void CreateShard(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::CreateShardRequest* request,
                       ::bedrock::metaserver::CreateShardResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void RemoveShard(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::RemoveShardRequest* request,
                       ::bedrock::metaserver::RemoveShardRequest* response,
                       ::google::protobuf::Closure* done);
  virtual void CreateStorage(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::CreateStorageRequest* request,
                       ::bedrock::metaserver::CreateStorageResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void DeleteStorage(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::DeleteStorageRequest* request,
                       ::bedrock::metaserver::DeleteStorageResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void UndeleteStorage(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::UndeleteStorageRequest* request,
                       ::bedrock::metaserver::UndeleteStorageResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void RenameStorage(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::RenameStorageRequest* request,
                       ::bedrock::metaserver::RenameStorageResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void ResizeStorage(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::ResizeStorageRequest* request,
                       ::bedrock::metaserver::ResizeStorageResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void GetStorages(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::GetStoragesRequest* request,
                       ::bedrock::metaserver::GetStoragesResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void AddDataServer(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::AddDataServerRequest* request,
                       ::bedrock::metaserver::AddDataServerResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void RemoveDataServer(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::RemoveDataServerRequest* request,
                       ::bedrock::metaserver::RemoveDataServerResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void ListDataServer(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::ListDataServerRequest* request,
                       ::bedrock::metaserver::ListDataServerResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void UpdateDataServer(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::UpdateDataServerRequest* request,
                       ::bedrock::metaserver::UpdateDataServerResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MetaService);
};

class MetaService_Stub : public MetaService {
 public:
  MetaService_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  MetaService_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~MetaService_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements MetaService ------------------------------------------

  void HeartBeat(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::HeartBeatRequest* request,
                       ::PROTOBUF_NAMESPACE_ID::Empty* response,
                       ::google::protobuf::Closure* done);
  void GetShardRoutes(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::GetShardRoutesRequest* request,
                       ::bedrock::metaserver::GetShardRoutesResponse* response,
                       ::google::protobuf::Closure* done);
  void ShardInfo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::ShardInfoRequest* request,
                       ::bedrock::metaserver::ShardInfoResponse* response,
                       ::google::protobuf::Closure* done);
  void CreateShard(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::CreateShardRequest* request,
                       ::bedrock::metaserver::CreateShardResponse* response,
                       ::google::protobuf::Closure* done);
  void RemoveShard(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::RemoveShardRequest* request,
                       ::bedrock::metaserver::RemoveShardRequest* response,
                       ::google::protobuf::Closure* done);
  void CreateStorage(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::CreateStorageRequest* request,
                       ::bedrock::metaserver::CreateStorageResponse* response,
                       ::google::protobuf::Closure* done);
  void DeleteStorage(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::DeleteStorageRequest* request,
                       ::bedrock::metaserver::DeleteStorageResponse* response,
                       ::google::protobuf::Closure* done);
  void UndeleteStorage(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::UndeleteStorageRequest* request,
                       ::bedrock::metaserver::UndeleteStorageResponse* response,
                       ::google::protobuf::Closure* done);
  void RenameStorage(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::RenameStorageRequest* request,
                       ::bedrock::metaserver::RenameStorageResponse* response,
                       ::google::protobuf::Closure* done);
  void ResizeStorage(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::ResizeStorageRequest* request,
                       ::bedrock::metaserver::ResizeStorageResponse* response,
                       ::google::protobuf::Closure* done);
  void GetStorages(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::GetStoragesRequest* request,
                       ::bedrock::metaserver::GetStoragesResponse* response,
                       ::google::protobuf::Closure* done);
  void AddDataServer(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::AddDataServerRequest* request,
                       ::bedrock::metaserver::AddDataServerResponse* response,
                       ::google::protobuf::Closure* done);
  void RemoveDataServer(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::RemoveDataServerRequest* request,
                       ::bedrock::metaserver::RemoveDataServerResponse* response,
                       ::google::protobuf::Closure* done);
  void ListDataServer(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::ListDataServerRequest* request,
                       ::bedrock::metaserver::ListDataServerResponse* response,
                       ::google::protobuf::Closure* done);
  void UpdateDataServer(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::metaserver::UpdateDataServerRequest* request,
                       ::bedrock::metaserver::UpdateDataServerResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MetaService_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Storage

// uint64 id = 1;
inline void Storage::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t Storage::_internal_id() const {
  return id_;
}
inline uint64_t Storage::id() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.Storage.id)
  return _internal_id();
}
inline void Storage::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void Storage::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.Storage.id)
}

// string name = 2;
inline void Storage::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Storage::name() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.Storage.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Storage::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bedrock.metaserver.Storage.name)
}
inline std::string* Storage::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.Storage.name)
  return _s;
}
inline const std::string& Storage::_internal_name() const {
  return name_.Get();
}
inline void Storage::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Storage::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Storage::release_name() {
  // @@protoc_insertion_point(field_release:bedrock.metaserver.Storage.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Storage::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bedrock.metaserver.Storage.name)
}

// .google.protobuf.Timestamp deleted_ts = 3;
inline bool Storage::_internal_has_deleted_ts() const {
  return this != internal_default_instance() && deleted_ts_ != nullptr;
}
inline bool Storage::has_deleted_ts() const {
  return _internal_has_deleted_ts();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Storage::_internal_deleted_ts() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = deleted_ts_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Storage::deleted_ts() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.Storage.deleted_ts)
  return _internal_deleted_ts();
}
inline void Storage::unsafe_arena_set_allocated_deleted_ts(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_ts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deleted_ts_);
  }
  deleted_ts_ = deleted_ts;
  if (deleted_ts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bedrock.metaserver.Storage.deleted_ts)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Storage::release_deleted_ts() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = deleted_ts_;
  deleted_ts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Storage::unsafe_arena_release_deleted_ts() {
  // @@protoc_insertion_point(field_release:bedrock.metaserver.Storage.deleted_ts)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = deleted_ts_;
  deleted_ts_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Storage::_internal_mutable_deleted_ts() {
  
  if (deleted_ts_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    deleted_ts_ = p;
  }
  return deleted_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Storage::mutable_deleted_ts() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_deleted_ts();
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.Storage.deleted_ts)
  return _msg;
}
inline void Storage::set_allocated_deleted_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_ts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(deleted_ts_);
  }
  if (deleted_ts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deleted_ts));
    if (message_arena != submessage_arena) {
      deleted_ts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deleted_ts, submessage_arena);
    }
    
  } else {
    
  }
  deleted_ts_ = deleted_ts;
  // @@protoc_insertion_point(field_set_allocated:bedrock.metaserver.Storage.deleted_ts)
}

// .google.protobuf.Timestamp create_ts = 4;
inline bool Storage::_internal_has_create_ts() const {
  return this != internal_default_instance() && create_ts_ != nullptr;
}
inline bool Storage::has_create_ts() const {
  return _internal_has_create_ts();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Storage::_internal_create_ts() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = create_ts_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Storage::create_ts() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.Storage.create_ts)
  return _internal_create_ts();
}
inline void Storage::unsafe_arena_set_allocated_create_ts(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_ts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_ts_);
  }
  create_ts_ = create_ts;
  if (create_ts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bedrock.metaserver.Storage.create_ts)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Storage::release_create_ts() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = create_ts_;
  create_ts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Storage::unsafe_arena_release_create_ts() {
  // @@protoc_insertion_point(field_release:bedrock.metaserver.Storage.create_ts)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = create_ts_;
  create_ts_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Storage::_internal_mutable_create_ts() {
  
  if (create_ts_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    create_ts_ = p;
  }
  return create_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Storage::mutable_create_ts() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_create_ts();
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.Storage.create_ts)
  return _msg;
}
inline void Storage::set_allocated_create_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* create_ts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_ts_);
  }
  if (create_ts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_ts));
    if (message_arena != submessage_arena) {
      create_ts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_ts, submessage_arena);
    }
    
  } else {
    
  }
  create_ts_ = create_ts;
  // @@protoc_insertion_point(field_set_allocated:bedrock.metaserver.Storage.create_ts)
}

// string owner = 5;
inline void Storage::clear_owner() {
  owner_.ClearToEmpty();
}
inline const std::string& Storage::owner() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.Storage.owner)
  return _internal_owner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Storage::set_owner(ArgT0&& arg0, ArgT... args) {
 
 owner_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bedrock.metaserver.Storage.owner)
}
inline std::string* Storage::mutable_owner() {
  std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.Storage.owner)
  return _s;
}
inline const std::string& Storage::_internal_owner() const {
  return owner_.Get();
}
inline void Storage::_internal_set_owner(const std::string& value) {
  
  owner_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Storage::_internal_mutable_owner() {
  
  return owner_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Storage::release_owner() {
  // @@protoc_insertion_point(field_release:bedrock.metaserver.Storage.owner)
  return owner_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Storage::set_allocated_owner(std::string* owner) {
  if (owner != nullptr) {
    
  } else {
    
  }
  owner_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    owner_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bedrock.metaserver.Storage.owner)
}

// -------------------------------------------------------------------

// Shard

// uint64 id = 1;
inline void Shard::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t Shard::_internal_id() const {
  return id_;
}
inline uint64_t Shard::id() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.Shard.id)
  return _internal_id();
}
inline void Shard::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void Shard::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.Shard.id)
}

// uint64 storage_id = 2;
inline void Shard::clear_storage_id() {
  storage_id_ = uint64_t{0u};
}
inline uint64_t Shard::_internal_storage_id() const {
  return storage_id_;
}
inline uint64_t Shard::storage_id() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.Shard.storage_id)
  return _internal_storage_id();
}
inline void Shard::_internal_set_storage_id(uint64_t value) {
  
  storage_id_ = value;
}
inline void Shard::set_storage_id(uint64_t value) {
  _internal_set_storage_id(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.Shard.storage_id)
}

// .google.protobuf.Timestamp replica_update_ts = 3;
inline bool Shard::_internal_has_replica_update_ts() const {
  return this != internal_default_instance() && replica_update_ts_ != nullptr;
}
inline bool Shard::has_replica_update_ts() const {
  return _internal_has_replica_update_ts();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Shard::_internal_replica_update_ts() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = replica_update_ts_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Shard::replica_update_ts() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.Shard.replica_update_ts)
  return _internal_replica_update_ts();
}
inline void Shard::unsafe_arena_set_allocated_replica_update_ts(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* replica_update_ts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(replica_update_ts_);
  }
  replica_update_ts_ = replica_update_ts;
  if (replica_update_ts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bedrock.metaserver.Shard.replica_update_ts)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Shard::release_replica_update_ts() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = replica_update_ts_;
  replica_update_ts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Shard::unsafe_arena_release_replica_update_ts() {
  // @@protoc_insertion_point(field_release:bedrock.metaserver.Shard.replica_update_ts)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = replica_update_ts_;
  replica_update_ts_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Shard::_internal_mutable_replica_update_ts() {
  
  if (replica_update_ts_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    replica_update_ts_ = p;
  }
  return replica_update_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Shard::mutable_replica_update_ts() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_replica_update_ts();
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.Shard.replica_update_ts)
  return _msg;
}
inline void Shard::set_allocated_replica_update_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* replica_update_ts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(replica_update_ts_);
  }
  if (replica_update_ts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(replica_update_ts));
    if (message_arena != submessage_arena) {
      replica_update_ts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, replica_update_ts, submessage_arena);
    }
    
  } else {
    
  }
  replica_update_ts_ = replica_update_ts;
  // @@protoc_insertion_point(field_set_allocated:bedrock.metaserver.Shard.replica_update_ts)
}

// repeated string replicates = 4;
inline int Shard::_internal_replicates_size() const {
  return replicates_.size();
}
inline int Shard::replicates_size() const {
  return _internal_replicates_size();
}
inline void Shard::clear_replicates() {
  replicates_.Clear();
}
inline std::string* Shard::add_replicates() {
  std::string* _s = _internal_add_replicates();
  // @@protoc_insertion_point(field_add_mutable:bedrock.metaserver.Shard.replicates)
  return _s;
}
inline const std::string& Shard::_internal_replicates(int index) const {
  return replicates_.Get(index);
}
inline const std::string& Shard::replicates(int index) const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.Shard.replicates)
  return _internal_replicates(index);
}
inline std::string* Shard::mutable_replicates(int index) {
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.Shard.replicates)
  return replicates_.Mutable(index);
}
inline void Shard::set_replicates(int index, const std::string& value) {
  replicates_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.Shard.replicates)
}
inline void Shard::set_replicates(int index, std::string&& value) {
  replicates_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bedrock.metaserver.Shard.replicates)
}
inline void Shard::set_replicates(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  replicates_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bedrock.metaserver.Shard.replicates)
}
inline void Shard::set_replicates(int index, const char* value, size_t size) {
  replicates_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bedrock.metaserver.Shard.replicates)
}
inline std::string* Shard::_internal_add_replicates() {
  return replicates_.Add();
}
inline void Shard::add_replicates(const std::string& value) {
  replicates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bedrock.metaserver.Shard.replicates)
}
inline void Shard::add_replicates(std::string&& value) {
  replicates_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bedrock.metaserver.Shard.replicates)
}
inline void Shard::add_replicates(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  replicates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bedrock.metaserver.Shard.replicates)
}
inline void Shard::add_replicates(const char* value, size_t size) {
  replicates_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bedrock.metaserver.Shard.replicates)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Shard::replicates() const {
  // @@protoc_insertion_point(field_list:bedrock.metaserver.Shard.replicates)
  return replicates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Shard::mutable_replicates() {
  // @@protoc_insertion_point(field_mutable_list:bedrock.metaserver.Shard.replicates)
  return &replicates_;
}

// bool is_deleted = 5;
inline void Shard::clear_is_deleted() {
  is_deleted_ = false;
}
inline bool Shard::_internal_is_deleted() const {
  return is_deleted_;
}
inline bool Shard::is_deleted() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.Shard.is_deleted)
  return _internal_is_deleted();
}
inline void Shard::_internal_set_is_deleted(bool value) {
  
  is_deleted_ = value;
}
inline void Shard::set_is_deleted(bool value) {
  _internal_set_is_deleted(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.Shard.is_deleted)
}

// .google.protobuf.Timestamp deleted_ts = 6;
inline bool Shard::_internal_has_deleted_ts() const {
  return this != internal_default_instance() && deleted_ts_ != nullptr;
}
inline bool Shard::has_deleted_ts() const {
  return _internal_has_deleted_ts();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Shard::_internal_deleted_ts() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = deleted_ts_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Shard::deleted_ts() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.Shard.deleted_ts)
  return _internal_deleted_ts();
}
inline void Shard::unsafe_arena_set_allocated_deleted_ts(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_ts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deleted_ts_);
  }
  deleted_ts_ = deleted_ts;
  if (deleted_ts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bedrock.metaserver.Shard.deleted_ts)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Shard::release_deleted_ts() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = deleted_ts_;
  deleted_ts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Shard::unsafe_arena_release_deleted_ts() {
  // @@protoc_insertion_point(field_release:bedrock.metaserver.Shard.deleted_ts)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = deleted_ts_;
  deleted_ts_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Shard::_internal_mutable_deleted_ts() {
  
  if (deleted_ts_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    deleted_ts_ = p;
  }
  return deleted_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Shard::mutable_deleted_ts() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_deleted_ts();
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.Shard.deleted_ts)
  return _msg;
}
inline void Shard::set_allocated_deleted_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_ts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(deleted_ts_);
  }
  if (deleted_ts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deleted_ts));
    if (message_arena != submessage_arena) {
      deleted_ts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deleted_ts, submessage_arena);
    }
    
  } else {
    
  }
  deleted_ts_ = deleted_ts;
  // @@protoc_insertion_point(field_set_allocated:bedrock.metaserver.Shard.deleted_ts)
}

// .google.protobuf.Timestamp create_ts = 7;
inline bool Shard::_internal_has_create_ts() const {
  return this != internal_default_instance() && create_ts_ != nullptr;
}
inline bool Shard::has_create_ts() const {
  return _internal_has_create_ts();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Shard::_internal_create_ts() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = create_ts_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Shard::create_ts() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.Shard.create_ts)
  return _internal_create_ts();
}
inline void Shard::unsafe_arena_set_allocated_create_ts(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_ts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_ts_);
  }
  create_ts_ = create_ts;
  if (create_ts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bedrock.metaserver.Shard.create_ts)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Shard::release_create_ts() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = create_ts_;
  create_ts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Shard::unsafe_arena_release_create_ts() {
  // @@protoc_insertion_point(field_release:bedrock.metaserver.Shard.create_ts)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = create_ts_;
  create_ts_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Shard::_internal_mutable_create_ts() {
  
  if (create_ts_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    create_ts_ = p;
  }
  return create_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Shard::mutable_create_ts() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_create_ts();
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.Shard.create_ts)
  return _msg;
}
inline void Shard::set_allocated_create_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* create_ts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_ts_);
  }
  if (create_ts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_ts));
    if (message_arena != submessage_arena) {
      create_ts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_ts, submessage_arena);
    }
    
  } else {
    
  }
  create_ts_ = create_ts;
  // @@protoc_insertion_point(field_set_allocated:bedrock.metaserver.Shard.create_ts)
}

// string leader = 8;
inline void Shard::clear_leader() {
  leader_.ClearToEmpty();
}
inline const std::string& Shard::leader() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.Shard.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Shard::set_leader(ArgT0&& arg0, ArgT... args) {
 
 leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bedrock.metaserver.Shard.leader)
}
inline std::string* Shard::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.Shard.leader)
  return _s;
}
inline const std::string& Shard::_internal_leader() const {
  return leader_.Get();
}
inline void Shard::_internal_set_leader(const std::string& value) {
  
  leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Shard::_internal_mutable_leader() {
  
  return leader_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Shard::release_leader() {
  // @@protoc_insertion_point(field_release:bedrock.metaserver.Shard.leader)
  return leader_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Shard::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    
  } else {
    
  }
  leader_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), leader,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (leader_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    leader_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bedrock.metaserver.Shard.leader)
}

// .google.protobuf.Timestamp leader_change_ts = 9;
inline bool Shard::_internal_has_leader_change_ts() const {
  return this != internal_default_instance() && leader_change_ts_ != nullptr;
}
inline bool Shard::has_leader_change_ts() const {
  return _internal_has_leader_change_ts();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Shard::_internal_leader_change_ts() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = leader_change_ts_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Shard::leader_change_ts() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.Shard.leader_change_ts)
  return _internal_leader_change_ts();
}
inline void Shard::unsafe_arena_set_allocated_leader_change_ts(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* leader_change_ts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(leader_change_ts_);
  }
  leader_change_ts_ = leader_change_ts;
  if (leader_change_ts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bedrock.metaserver.Shard.leader_change_ts)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Shard::release_leader_change_ts() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = leader_change_ts_;
  leader_change_ts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Shard::unsafe_arena_release_leader_change_ts() {
  // @@protoc_insertion_point(field_release:bedrock.metaserver.Shard.leader_change_ts)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = leader_change_ts_;
  leader_change_ts_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Shard::_internal_mutable_leader_change_ts() {
  
  if (leader_change_ts_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    leader_change_ts_ = p;
  }
  return leader_change_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Shard::mutable_leader_change_ts() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_leader_change_ts();
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.Shard.leader_change_ts)
  return _msg;
}
inline void Shard::set_allocated_leader_change_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* leader_change_ts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(leader_change_ts_);
  }
  if (leader_change_ts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(leader_change_ts));
    if (message_arena != submessage_arena) {
      leader_change_ts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leader_change_ts, submessage_arena);
    }
    
  } else {
    
  }
  leader_change_ts_ = leader_change_ts;
  // @@protoc_insertion_point(field_set_allocated:bedrock.metaserver.Shard.leader_change_ts)
}

// -------------------------------------------------------------------

// DataServer

// string ip = 1;
inline void DataServer::clear_ip() {
  ip_.ClearToEmpty();
}
inline const std::string& DataServer::ip() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.DataServer.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataServer::set_ip(ArgT0&& arg0, ArgT... args) {
 
 ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bedrock.metaserver.DataServer.ip)
}
inline std::string* DataServer::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.DataServer.ip)
  return _s;
}
inline const std::string& DataServer::_internal_ip() const {
  return ip_.Get();
}
inline void DataServer::_internal_set_ip(const std::string& value) {
  
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataServer::_internal_mutable_ip() {
  
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataServer::release_ip() {
  // @@protoc_insertion_point(field_release:bedrock.metaserver.DataServer.ip)
  return ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataServer::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bedrock.metaserver.DataServer.ip)
}

// string port = 2;
inline void DataServer::clear_port() {
  port_.ClearToEmpty();
}
inline const std::string& DataServer::port() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.DataServer.port)
  return _internal_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataServer::set_port(ArgT0&& arg0, ArgT... args) {
 
 port_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bedrock.metaserver.DataServer.port)
}
inline std::string* DataServer::mutable_port() {
  std::string* _s = _internal_mutable_port();
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.DataServer.port)
  return _s;
}
inline const std::string& DataServer::_internal_port() const {
  return port_.Get();
}
inline void DataServer::_internal_set_port(const std::string& value) {
  
  port_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataServer::_internal_mutable_port() {
  
  return port_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataServer::release_port() {
  // @@protoc_insertion_point(field_release:bedrock.metaserver.DataServer.port)
  return port_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataServer::set_allocated_port(std::string* port) {
  if (port != nullptr) {
    
  } else {
    
  }
  port_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), port,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (port_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    port_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bedrock.metaserver.DataServer.port)
}

// uint64 capacity = 3;
inline void DataServer::clear_capacity() {
  capacity_ = uint64_t{0u};
}
inline uint64_t DataServer::_internal_capacity() const {
  return capacity_;
}
inline uint64_t DataServer::capacity() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.DataServer.capacity)
  return _internal_capacity();
}
inline void DataServer::_internal_set_capacity(uint64_t value) {
  
  capacity_ = value;
}
inline void DataServer::set_capacity(uint64_t value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.DataServer.capacity)
}

// uint64 free = 4;
inline void DataServer::clear_free() {
  free_ = uint64_t{0u};
}
inline uint64_t DataServer::_internal_free() const {
  return free_;
}
inline uint64_t DataServer::free() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.DataServer.free)
  return _internal_free();
}
inline void DataServer::_internal_set_free(uint64_t value) {
  
  free_ = value;
}
inline void DataServer::set_free(uint64_t value) {
  _internal_set_free(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.DataServer.free)
}

// .google.protobuf.Timestamp last_heartbeat_ts = 5;
inline bool DataServer::_internal_has_last_heartbeat_ts() const {
  return this != internal_default_instance() && last_heartbeat_ts_ != nullptr;
}
inline bool DataServer::has_last_heartbeat_ts() const {
  return _internal_has_last_heartbeat_ts();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DataServer::_internal_last_heartbeat_ts() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = last_heartbeat_ts_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DataServer::last_heartbeat_ts() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.DataServer.last_heartbeat_ts)
  return _internal_last_heartbeat_ts();
}
inline void DataServer::unsafe_arena_set_allocated_last_heartbeat_ts(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_heartbeat_ts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_heartbeat_ts_);
  }
  last_heartbeat_ts_ = last_heartbeat_ts;
  if (last_heartbeat_ts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bedrock.metaserver.DataServer.last_heartbeat_ts)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DataServer::release_last_heartbeat_ts() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_heartbeat_ts_;
  last_heartbeat_ts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DataServer::unsafe_arena_release_last_heartbeat_ts() {
  // @@protoc_insertion_point(field_release:bedrock.metaserver.DataServer.last_heartbeat_ts)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_heartbeat_ts_;
  last_heartbeat_ts_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DataServer::_internal_mutable_last_heartbeat_ts() {
  
  if (last_heartbeat_ts_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    last_heartbeat_ts_ = p;
  }
  return last_heartbeat_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DataServer::mutable_last_heartbeat_ts() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_heartbeat_ts();
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.DataServer.last_heartbeat_ts)
  return _msg;
}
inline void DataServer::set_allocated_last_heartbeat_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* last_heartbeat_ts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_heartbeat_ts_);
  }
  if (last_heartbeat_ts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_heartbeat_ts));
    if (message_arena != submessage_arena) {
      last_heartbeat_ts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_heartbeat_ts, submessage_arena);
    }
    
  } else {
    
  }
  last_heartbeat_ts_ = last_heartbeat_ts;
  // @@protoc_insertion_point(field_set_allocated:bedrock.metaserver.DataServer.last_heartbeat_ts)
}

// string status = 6;
inline void DataServer::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& DataServer::status() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.DataServer.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataServer::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bedrock.metaserver.DataServer.status)
}
inline std::string* DataServer::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.DataServer.status)
  return _s;
}
inline const std::string& DataServer::_internal_status() const {
  return status_.Get();
}
inline void DataServer::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataServer::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataServer::release_status() {
  // @@protoc_insertion_point(field_release:bedrock.metaserver.DataServer.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataServer::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (status_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bedrock.metaserver.DataServer.status)
}

// string idc = 7;
inline void DataServer::clear_idc() {
  idc_.ClearToEmpty();
}
inline const std::string& DataServer::idc() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.DataServer.idc)
  return _internal_idc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataServer::set_idc(ArgT0&& arg0, ArgT... args) {
 
 idc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bedrock.metaserver.DataServer.idc)
}
inline std::string* DataServer::mutable_idc() {
  std::string* _s = _internal_mutable_idc();
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.DataServer.idc)
  return _s;
}
inline const std::string& DataServer::_internal_idc() const {
  return idc_.Get();
}
inline void DataServer::_internal_set_idc(const std::string& value) {
  
  idc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataServer::_internal_mutable_idc() {
  
  return idc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataServer::release_idc() {
  // @@protoc_insertion_point(field_release:bedrock.metaserver.DataServer.idc)
  return idc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataServer::set_allocated_idc(std::string* idc) {
  if (idc != nullptr) {
    
  } else {
    
  }
  idc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), idc,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (idc_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    idc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bedrock.metaserver.DataServer.idc)
}

// -------------------------------------------------------------------

// Replicate

// repeated string addrs = 1;
inline int Replicate::_internal_addrs_size() const {
  return addrs_.size();
}
inline int Replicate::addrs_size() const {
  return _internal_addrs_size();
}
inline void Replicate::clear_addrs() {
  addrs_.Clear();
}
inline std::string* Replicate::add_addrs() {
  std::string* _s = _internal_add_addrs();
  // @@protoc_insertion_point(field_add_mutable:bedrock.metaserver.Replicate.addrs)
  return _s;
}
inline const std::string& Replicate::_internal_addrs(int index) const {
  return addrs_.Get(index);
}
inline const std::string& Replicate::addrs(int index) const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.Replicate.addrs)
  return _internal_addrs(index);
}
inline std::string* Replicate::mutable_addrs(int index) {
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.Replicate.addrs)
  return addrs_.Mutable(index);
}
inline void Replicate::set_addrs(int index, const std::string& value) {
  addrs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.Replicate.addrs)
}
inline void Replicate::set_addrs(int index, std::string&& value) {
  addrs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bedrock.metaserver.Replicate.addrs)
}
inline void Replicate::set_addrs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addrs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bedrock.metaserver.Replicate.addrs)
}
inline void Replicate::set_addrs(int index, const char* value, size_t size) {
  addrs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bedrock.metaserver.Replicate.addrs)
}
inline std::string* Replicate::_internal_add_addrs() {
  return addrs_.Add();
}
inline void Replicate::add_addrs(const std::string& value) {
  addrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bedrock.metaserver.Replicate.addrs)
}
inline void Replicate::add_addrs(std::string&& value) {
  addrs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bedrock.metaserver.Replicate.addrs)
}
inline void Replicate::add_addrs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bedrock.metaserver.Replicate.addrs)
}
inline void Replicate::add_addrs(const char* value, size_t size) {
  addrs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bedrock.metaserver.Replicate.addrs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Replicate::addrs() const {
  // @@protoc_insertion_point(field_list:bedrock.metaserver.Replicate.addrs)
  return addrs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Replicate::mutable_addrs() {
  // @@protoc_insertion_point(field_mutable_list:bedrock.metaserver.Replicate.addrs)
  return &addrs_;
}

// -------------------------------------------------------------------

// HeartBeatRequest

// string addr = 1;
inline void HeartBeatRequest::clear_addr() {
  addr_.ClearToEmpty();
}
inline const std::string& HeartBeatRequest::addr() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.HeartBeatRequest.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeartBeatRequest::set_addr(ArgT0&& arg0, ArgT... args) {
 
 addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bedrock.metaserver.HeartBeatRequest.addr)
}
inline std::string* HeartBeatRequest::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.HeartBeatRequest.addr)
  return _s;
}
inline const std::string& HeartBeatRequest::_internal_addr() const {
  return addr_.Get();
}
inline void HeartBeatRequest::_internal_set_addr(const std::string& value) {
  
  addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HeartBeatRequest::_internal_mutable_addr() {
  
  return addr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HeartBeatRequest::release_addr() {
  // @@protoc_insertion_point(field_release:bedrock.metaserver.HeartBeatRequest.addr)
  return addr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void HeartBeatRequest::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (addr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bedrock.metaserver.HeartBeatRequest.addr)
}

// -------------------------------------------------------------------

// HeartBeatResponse

// -------------------------------------------------------------------

// CreateStorageRequest

// string name = 1;
inline void CreateStorageRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateStorageRequest::name() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.CreateStorageRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateStorageRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bedrock.metaserver.CreateStorageRequest.name)
}
inline std::string* CreateStorageRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.CreateStorageRequest.name)
  return _s;
}
inline const std::string& CreateStorageRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateStorageRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateStorageRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateStorageRequest::release_name() {
  // @@protoc_insertion_point(field_release:bedrock.metaserver.CreateStorageRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateStorageRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bedrock.metaserver.CreateStorageRequest.name)
}

// -------------------------------------------------------------------

// CreateStorageResponse

// uint64 id = 1;
inline void CreateStorageResponse::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t CreateStorageResponse::_internal_id() const {
  return id_;
}
inline uint64_t CreateStorageResponse::id() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.CreateStorageResponse.id)
  return _internal_id();
}
inline void CreateStorageResponse::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void CreateStorageResponse::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.CreateStorageResponse.id)
}

// -------------------------------------------------------------------

// CreateShardRequest

// uint64 shard_id = 1;
inline void CreateShardRequest::clear_shard_id() {
  shard_id_ = uint64_t{0u};
}
inline uint64_t CreateShardRequest::_internal_shard_id() const {
  return shard_id_;
}
inline uint64_t CreateShardRequest::shard_id() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.CreateShardRequest.shard_id)
  return _internal_shard_id();
}
inline void CreateShardRequest::_internal_set_shard_id(uint64_t value) {
  
  shard_id_ = value;
}
inline void CreateShardRequest::set_shard_id(uint64_t value) {
  _internal_set_shard_id(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.CreateShardRequest.shard_id)
}

// uint64 storage_id = 2;
inline void CreateShardRequest::clear_storage_id() {
  storage_id_ = uint64_t{0u};
}
inline uint64_t CreateShardRequest::_internal_storage_id() const {
  return storage_id_;
}
inline uint64_t CreateShardRequest::storage_id() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.CreateShardRequest.storage_id)
  return _internal_storage_id();
}
inline void CreateShardRequest::_internal_set_storage_id(uint64_t value) {
  
  storage_id_ = value;
}
inline void CreateShardRequest::set_storage_id(uint64_t value) {
  _internal_set_storage_id(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.CreateShardRequest.storage_id)
}

// -------------------------------------------------------------------

// CreateShardResponse

// -------------------------------------------------------------------

// RemoveShardRequest

// uint64 shard_id = 1;
inline void RemoveShardRequest::clear_shard_id() {
  shard_id_ = uint64_t{0u};
}
inline uint64_t RemoveShardRequest::_internal_shard_id() const {
  return shard_id_;
}
inline uint64_t RemoveShardRequest::shard_id() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.RemoveShardRequest.shard_id)
  return _internal_shard_id();
}
inline void RemoveShardRequest::_internal_set_shard_id(uint64_t value) {
  
  shard_id_ = value;
}
inline void RemoveShardRequest::set_shard_id(uint64_t value) {
  _internal_set_shard_id(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.RemoveShardRequest.shard_id)
}

// uint64 storage_id = 2;
inline void RemoveShardRequest::clear_storage_id() {
  storage_id_ = uint64_t{0u};
}
inline uint64_t RemoveShardRequest::_internal_storage_id() const {
  return storage_id_;
}
inline uint64_t RemoveShardRequest::storage_id() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.RemoveShardRequest.storage_id)
  return _internal_storage_id();
}
inline void RemoveShardRequest::_internal_set_storage_id(uint64_t value) {
  
  storage_id_ = value;
}
inline void RemoveShardRequest::set_storage_id(uint64_t value) {
  _internal_set_storage_id(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.RemoveShardRequest.storage_id)
}

// -------------------------------------------------------------------

// RemoveShardResponse

// -------------------------------------------------------------------

// DeleteStorageRequest

// uint64 id = 1;
inline void DeleteStorageRequest::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t DeleteStorageRequest::_internal_id() const {
  return id_;
}
inline uint64_t DeleteStorageRequest::id() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.DeleteStorageRequest.id)
  return _internal_id();
}
inline void DeleteStorageRequest::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void DeleteStorageRequest::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.DeleteStorageRequest.id)
}

// bool real_delete = 2;
inline void DeleteStorageRequest::clear_real_delete() {
  real_delete_ = false;
}
inline bool DeleteStorageRequest::_internal_real_delete() const {
  return real_delete_;
}
inline bool DeleteStorageRequest::real_delete() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.DeleteStorageRequest.real_delete)
  return _internal_real_delete();
}
inline void DeleteStorageRequest::_internal_set_real_delete(bool value) {
  
  real_delete_ = value;
}
inline void DeleteStorageRequest::set_real_delete(bool value) {
  _internal_set_real_delete(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.DeleteStorageRequest.real_delete)
}

// uint64 recycle_after = 3;
inline void DeleteStorageRequest::clear_recycle_after() {
  recycle_after_ = uint64_t{0u};
}
inline uint64_t DeleteStorageRequest::_internal_recycle_after() const {
  return recycle_after_;
}
inline uint64_t DeleteStorageRequest::recycle_after() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.DeleteStorageRequest.recycle_after)
  return _internal_recycle_after();
}
inline void DeleteStorageRequest::_internal_set_recycle_after(uint64_t value) {
  
  recycle_after_ = value;
}
inline void DeleteStorageRequest::set_recycle_after(uint64_t value) {
  _internal_set_recycle_after(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.DeleteStorageRequest.recycle_after)
}

// -------------------------------------------------------------------

// DeleteStorageResponse

// -------------------------------------------------------------------

// UndeleteStorageRequest

// uint64 id = 1;
inline void UndeleteStorageRequest::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t UndeleteStorageRequest::_internal_id() const {
  return id_;
}
inline uint64_t UndeleteStorageRequest::id() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.UndeleteStorageRequest.id)
  return _internal_id();
}
inline void UndeleteStorageRequest::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void UndeleteStorageRequest::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.UndeleteStorageRequest.id)
}

// -------------------------------------------------------------------

// UndeleteStorageResponse

// -------------------------------------------------------------------

// RenameStorageRequest

// uint64 id = 1;
inline void RenameStorageRequest::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t RenameStorageRequest::_internal_id() const {
  return id_;
}
inline uint64_t RenameStorageRequest::id() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.RenameStorageRequest.id)
  return _internal_id();
}
inline void RenameStorageRequest::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void RenameStorageRequest::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.RenameStorageRequest.id)
}

// string new_name = 2;
inline void RenameStorageRequest::clear_new_name() {
  new_name_.ClearToEmpty();
}
inline const std::string& RenameStorageRequest::new_name() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.RenameStorageRequest.new_name)
  return _internal_new_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameStorageRequest::set_new_name(ArgT0&& arg0, ArgT... args) {
 
 new_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bedrock.metaserver.RenameStorageRequest.new_name)
}
inline std::string* RenameStorageRequest::mutable_new_name() {
  std::string* _s = _internal_mutable_new_name();
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.RenameStorageRequest.new_name)
  return _s;
}
inline const std::string& RenameStorageRequest::_internal_new_name() const {
  return new_name_.Get();
}
inline void RenameStorageRequest::_internal_set_new_name(const std::string& value) {
  
  new_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RenameStorageRequest::_internal_mutable_new_name() {
  
  return new_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RenameStorageRequest::release_new_name() {
  // @@protoc_insertion_point(field_release:bedrock.metaserver.RenameStorageRequest.new_name)
  return new_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RenameStorageRequest::set_allocated_new_name(std::string* new_name) {
  if (new_name != nullptr) {
    
  } else {
    
  }
  new_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (new_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    new_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bedrock.metaserver.RenameStorageRequest.new_name)
}

// -------------------------------------------------------------------

// RenameStorageResponse

// -------------------------------------------------------------------

// ResizeStorageRequest

// uint64 id = 1;
inline void ResizeStorageRequest::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t ResizeStorageRequest::_internal_id() const {
  return id_;
}
inline uint64_t ResizeStorageRequest::id() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.ResizeStorageRequest.id)
  return _internal_id();
}
inline void ResizeStorageRequest::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void ResizeStorageRequest::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.ResizeStorageRequest.id)
}

// uint64 new_size = 2;
inline void ResizeStorageRequest::clear_new_size() {
  new_size_ = uint64_t{0u};
}
inline uint64_t ResizeStorageRequest::_internal_new_size() const {
  return new_size_;
}
inline uint64_t ResizeStorageRequest::new_size() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.ResizeStorageRequest.new_size)
  return _internal_new_size();
}
inline void ResizeStorageRequest::_internal_set_new_size(uint64_t value) {
  
  new_size_ = value;
}
inline void ResizeStorageRequest::set_new_size(uint64_t value) {
  _internal_set_new_size(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.ResizeStorageRequest.new_size)
}

// uint64 new_shard_count = 3;
inline void ResizeStorageRequest::clear_new_shard_count() {
  new_shard_count_ = uint64_t{0u};
}
inline uint64_t ResizeStorageRequest::_internal_new_shard_count() const {
  return new_shard_count_;
}
inline uint64_t ResizeStorageRequest::new_shard_count() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.ResizeStorageRequest.new_shard_count)
  return _internal_new_shard_count();
}
inline void ResizeStorageRequest::_internal_set_new_shard_count(uint64_t value) {
  
  new_shard_count_ = value;
}
inline void ResizeStorageRequest::set_new_shard_count(uint64_t value) {
  _internal_set_new_shard_count(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.ResizeStorageRequest.new_shard_count)
}

// -------------------------------------------------------------------

// ResizeStorageResponse

// -------------------------------------------------------------------

// GetStoragesRequest

// repeated uint64 ids = 1;
inline int GetStoragesRequest::_internal_ids_size() const {
  return ids_.size();
}
inline int GetStoragesRequest::ids_size() const {
  return _internal_ids_size();
}
inline void GetStoragesRequest::clear_ids() {
  ids_.Clear();
}
inline uint64_t GetStoragesRequest::_internal_ids(int index) const {
  return ids_.Get(index);
}
inline uint64_t GetStoragesRequest::ids(int index) const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.GetStoragesRequest.ids)
  return _internal_ids(index);
}
inline void GetStoragesRequest::set_ids(int index, uint64_t value) {
  ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.GetStoragesRequest.ids)
}
inline void GetStoragesRequest::_internal_add_ids(uint64_t value) {
  ids_.Add(value);
}
inline void GetStoragesRequest::add_ids(uint64_t value) {
  _internal_add_ids(value);
  // @@protoc_insertion_point(field_add:bedrock.metaserver.GetStoragesRequest.ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
GetStoragesRequest::_internal_ids() const {
  return ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
GetStoragesRequest::ids() const {
  // @@protoc_insertion_point(field_list:bedrock.metaserver.GetStoragesRequest.ids)
  return _internal_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
GetStoragesRequest::_internal_mutable_ids() {
  return &ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
GetStoragesRequest::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:bedrock.metaserver.GetStoragesRequest.ids)
  return _internal_mutable_ids();
}

// repeated string names = 2;
inline int GetStoragesRequest::_internal_names_size() const {
  return names_.size();
}
inline int GetStoragesRequest::names_size() const {
  return _internal_names_size();
}
inline void GetStoragesRequest::clear_names() {
  names_.Clear();
}
inline std::string* GetStoragesRequest::add_names() {
  std::string* _s = _internal_add_names();
  // @@protoc_insertion_point(field_add_mutable:bedrock.metaserver.GetStoragesRequest.names)
  return _s;
}
inline const std::string& GetStoragesRequest::_internal_names(int index) const {
  return names_.Get(index);
}
inline const std::string& GetStoragesRequest::names(int index) const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.GetStoragesRequest.names)
  return _internal_names(index);
}
inline std::string* GetStoragesRequest::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.GetStoragesRequest.names)
  return names_.Mutable(index);
}
inline void GetStoragesRequest::set_names(int index, const std::string& value) {
  names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.GetStoragesRequest.names)
}
inline void GetStoragesRequest::set_names(int index, std::string&& value) {
  names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bedrock.metaserver.GetStoragesRequest.names)
}
inline void GetStoragesRequest::set_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bedrock.metaserver.GetStoragesRequest.names)
}
inline void GetStoragesRequest::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bedrock.metaserver.GetStoragesRequest.names)
}
inline std::string* GetStoragesRequest::_internal_add_names() {
  return names_.Add();
}
inline void GetStoragesRequest::add_names(const std::string& value) {
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bedrock.metaserver.GetStoragesRequest.names)
}
inline void GetStoragesRequest::add_names(std::string&& value) {
  names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bedrock.metaserver.GetStoragesRequest.names)
}
inline void GetStoragesRequest::add_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bedrock.metaserver.GetStoragesRequest.names)
}
inline void GetStoragesRequest::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bedrock.metaserver.GetStoragesRequest.names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetStoragesRequest::names() const {
  // @@protoc_insertion_point(field_list:bedrock.metaserver.GetStoragesRequest.names)
  return names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetStoragesRequest::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:bedrock.metaserver.GetStoragesRequest.names)
  return &names_;
}

// -------------------------------------------------------------------

// GetStoragesResponse

// repeated .bedrock.metaserver.Storage storages = 1;
inline int GetStoragesResponse::_internal_storages_size() const {
  return storages_.size();
}
inline int GetStoragesResponse::storages_size() const {
  return _internal_storages_size();
}
inline void GetStoragesResponse::clear_storages() {
  storages_.Clear();
}
inline ::bedrock::metaserver::Storage* GetStoragesResponse::mutable_storages(int index) {
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.GetStoragesResponse.storages)
  return storages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bedrock::metaserver::Storage >*
GetStoragesResponse::mutable_storages() {
  // @@protoc_insertion_point(field_mutable_list:bedrock.metaserver.GetStoragesResponse.storages)
  return &storages_;
}
inline const ::bedrock::metaserver::Storage& GetStoragesResponse::_internal_storages(int index) const {
  return storages_.Get(index);
}
inline const ::bedrock::metaserver::Storage& GetStoragesResponse::storages(int index) const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.GetStoragesResponse.storages)
  return _internal_storages(index);
}
inline ::bedrock::metaserver::Storage* GetStoragesResponse::_internal_add_storages() {
  return storages_.Add();
}
inline ::bedrock::metaserver::Storage* GetStoragesResponse::add_storages() {
  ::bedrock::metaserver::Storage* _add = _internal_add_storages();
  // @@protoc_insertion_point(field_add:bedrock.metaserver.GetStoragesResponse.storages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bedrock::metaserver::Storage >&
GetStoragesResponse::storages() const {
  // @@protoc_insertion_point(field_list:bedrock.metaserver.GetStoragesResponse.storages)
  return storages_;
}

// -------------------------------------------------------------------

// ShardRange

// uint64 start_shard_id = 1;
inline void ShardRange::clear_start_shard_id() {
  start_shard_id_ = uint64_t{0u};
}
inline uint64_t ShardRange::_internal_start_shard_id() const {
  return start_shard_id_;
}
inline uint64_t ShardRange::start_shard_id() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.ShardRange.start_shard_id)
  return _internal_start_shard_id();
}
inline void ShardRange::_internal_set_start_shard_id(uint64_t value) {
  
  start_shard_id_ = value;
}
inline void ShardRange::set_start_shard_id(uint64_t value) {
  _internal_set_start_shard_id(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.ShardRange.start_shard_id)
}

// uint64 offset = 2;
inline void ShardRange::clear_offset() {
  offset_ = uint64_t{0u};
}
inline uint64_t ShardRange::_internal_offset() const {
  return offset_;
}
inline uint64_t ShardRange::offset() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.ShardRange.offset)
  return _internal_offset();
}
inline void ShardRange::_internal_set_offset(uint64_t value) {
  
  offset_ = value;
}
inline void ShardRange::set_offset(uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.ShardRange.offset)
}

// -------------------------------------------------------------------

// RouteRecord

// uint64 shard_id = 1;
inline void RouteRecord::clear_shard_id() {
  shard_id_ = uint64_t{0u};
}
inline uint64_t RouteRecord::_internal_shard_id() const {
  return shard_id_;
}
inline uint64_t RouteRecord::shard_id() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.RouteRecord.shard_id)
  return _internal_shard_id();
}
inline void RouteRecord::_internal_set_shard_id(uint64_t value) {
  
  shard_id_ = value;
}
inline void RouteRecord::set_shard_id(uint64_t value) {
  _internal_set_shard_id(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.RouteRecord.shard_id)
}

// repeated string addrs = 2;
inline int RouteRecord::_internal_addrs_size() const {
  return addrs_.size();
}
inline int RouteRecord::addrs_size() const {
  return _internal_addrs_size();
}
inline void RouteRecord::clear_addrs() {
  addrs_.Clear();
}
inline std::string* RouteRecord::add_addrs() {
  std::string* _s = _internal_add_addrs();
  // @@protoc_insertion_point(field_add_mutable:bedrock.metaserver.RouteRecord.addrs)
  return _s;
}
inline const std::string& RouteRecord::_internal_addrs(int index) const {
  return addrs_.Get(index);
}
inline const std::string& RouteRecord::addrs(int index) const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.RouteRecord.addrs)
  return _internal_addrs(index);
}
inline std::string* RouteRecord::mutable_addrs(int index) {
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.RouteRecord.addrs)
  return addrs_.Mutable(index);
}
inline void RouteRecord::set_addrs(int index, const std::string& value) {
  addrs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.RouteRecord.addrs)
}
inline void RouteRecord::set_addrs(int index, std::string&& value) {
  addrs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bedrock.metaserver.RouteRecord.addrs)
}
inline void RouteRecord::set_addrs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addrs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bedrock.metaserver.RouteRecord.addrs)
}
inline void RouteRecord::set_addrs(int index, const char* value, size_t size) {
  addrs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bedrock.metaserver.RouteRecord.addrs)
}
inline std::string* RouteRecord::_internal_add_addrs() {
  return addrs_.Add();
}
inline void RouteRecord::add_addrs(const std::string& value) {
  addrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bedrock.metaserver.RouteRecord.addrs)
}
inline void RouteRecord::add_addrs(std::string&& value) {
  addrs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bedrock.metaserver.RouteRecord.addrs)
}
inline void RouteRecord::add_addrs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bedrock.metaserver.RouteRecord.addrs)
}
inline void RouteRecord::add_addrs(const char* value, size_t size) {
  addrs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bedrock.metaserver.RouteRecord.addrs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RouteRecord::addrs() const {
  // @@protoc_insertion_point(field_list:bedrock.metaserver.RouteRecord.addrs)
  return addrs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RouteRecord::mutable_addrs() {
  // @@protoc_insertion_point(field_mutable_list:bedrock.metaserver.RouteRecord.addrs)
  return &addrs_;
}

// -------------------------------------------------------------------

// ShardList

// repeated uint64 shard_ids = 1;
inline int ShardList::_internal_shard_ids_size() const {
  return shard_ids_.size();
}
inline int ShardList::shard_ids_size() const {
  return _internal_shard_ids_size();
}
inline void ShardList::clear_shard_ids() {
  shard_ids_.Clear();
}
inline uint64_t ShardList::_internal_shard_ids(int index) const {
  return shard_ids_.Get(index);
}
inline uint64_t ShardList::shard_ids(int index) const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.ShardList.shard_ids)
  return _internal_shard_ids(index);
}
inline void ShardList::set_shard_ids(int index, uint64_t value) {
  shard_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.ShardList.shard_ids)
}
inline void ShardList::_internal_add_shard_ids(uint64_t value) {
  shard_ids_.Add(value);
}
inline void ShardList::add_shard_ids(uint64_t value) {
  _internal_add_shard_ids(value);
  // @@protoc_insertion_point(field_add:bedrock.metaserver.ShardList.shard_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
ShardList::_internal_shard_ids() const {
  return shard_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
ShardList::shard_ids() const {
  // @@protoc_insertion_point(field_list:bedrock.metaserver.ShardList.shard_ids)
  return _internal_shard_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
ShardList::_internal_mutable_shard_ids() {
  return &shard_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
ShardList::mutable_shard_ids() {
  // @@protoc_insertion_point(field_mutable_list:bedrock.metaserver.ShardList.shard_ids)
  return _internal_mutable_shard_ids();
}

// -------------------------------------------------------------------

// GetShardRoutesRequest

// .bedrock.metaserver.ShardList shards_list = 1;
inline bool GetShardRoutesRequest::_internal_has_shards_list() const {
  return shards_case() == kShardsList;
}
inline bool GetShardRoutesRequest::has_shards_list() const {
  return _internal_has_shards_list();
}
inline void GetShardRoutesRequest::set_has_shards_list() {
  _oneof_case_[0] = kShardsList;
}
inline void GetShardRoutesRequest::clear_shards_list() {
  if (_internal_has_shards_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete shards_.shards_list_;
    }
    clear_has_shards();
  }
}
inline ::bedrock::metaserver::ShardList* GetShardRoutesRequest::release_shards_list() {
  // @@protoc_insertion_point(field_release:bedrock.metaserver.GetShardRoutesRequest.shards_list)
  if (_internal_has_shards_list()) {
    clear_has_shards();
      ::bedrock::metaserver::ShardList* temp = shards_.shards_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    shards_.shards_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bedrock::metaserver::ShardList& GetShardRoutesRequest::_internal_shards_list() const {
  return _internal_has_shards_list()
      ? *shards_.shards_list_
      : reinterpret_cast< ::bedrock::metaserver::ShardList&>(::bedrock::metaserver::_ShardList_default_instance_);
}
inline const ::bedrock::metaserver::ShardList& GetShardRoutesRequest::shards_list() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.GetShardRoutesRequest.shards_list)
  return _internal_shards_list();
}
inline ::bedrock::metaserver::ShardList* GetShardRoutesRequest::unsafe_arena_release_shards_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bedrock.metaserver.GetShardRoutesRequest.shards_list)
  if (_internal_has_shards_list()) {
    clear_has_shards();
    ::bedrock::metaserver::ShardList* temp = shards_.shards_list_;
    shards_.shards_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetShardRoutesRequest::unsafe_arena_set_allocated_shards_list(::bedrock::metaserver::ShardList* shards_list) {
  clear_shards();
  if (shards_list) {
    set_has_shards_list();
    shards_.shards_list_ = shards_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bedrock.metaserver.GetShardRoutesRequest.shards_list)
}
inline ::bedrock::metaserver::ShardList* GetShardRoutesRequest::_internal_mutable_shards_list() {
  if (!_internal_has_shards_list()) {
    clear_shards();
    set_has_shards_list();
    shards_.shards_list_ = CreateMaybeMessage< ::bedrock::metaserver::ShardList >(GetArenaForAllocation());
  }
  return shards_.shards_list_;
}
inline ::bedrock::metaserver::ShardList* GetShardRoutesRequest::mutable_shards_list() {
  ::bedrock::metaserver::ShardList* _msg = _internal_mutable_shards_list();
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.GetShardRoutesRequest.shards_list)
  return _msg;
}

// .bedrock.metaserver.ShardRange shard_range = 2;
inline bool GetShardRoutesRequest::_internal_has_shard_range() const {
  return shards_case() == kShardRange;
}
inline bool GetShardRoutesRequest::has_shard_range() const {
  return _internal_has_shard_range();
}
inline void GetShardRoutesRequest::set_has_shard_range() {
  _oneof_case_[0] = kShardRange;
}
inline void GetShardRoutesRequest::clear_shard_range() {
  if (_internal_has_shard_range()) {
    if (GetArenaForAllocation() == nullptr) {
      delete shards_.shard_range_;
    }
    clear_has_shards();
  }
}
inline ::bedrock::metaserver::ShardRange* GetShardRoutesRequest::release_shard_range() {
  // @@protoc_insertion_point(field_release:bedrock.metaserver.GetShardRoutesRequest.shard_range)
  if (_internal_has_shard_range()) {
    clear_has_shards();
      ::bedrock::metaserver::ShardRange* temp = shards_.shard_range_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    shards_.shard_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bedrock::metaserver::ShardRange& GetShardRoutesRequest::_internal_shard_range() const {
  return _internal_has_shard_range()
      ? *shards_.shard_range_
      : reinterpret_cast< ::bedrock::metaserver::ShardRange&>(::bedrock::metaserver::_ShardRange_default_instance_);
}
inline const ::bedrock::metaserver::ShardRange& GetShardRoutesRequest::shard_range() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.GetShardRoutesRequest.shard_range)
  return _internal_shard_range();
}
inline ::bedrock::metaserver::ShardRange* GetShardRoutesRequest::unsafe_arena_release_shard_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bedrock.metaserver.GetShardRoutesRequest.shard_range)
  if (_internal_has_shard_range()) {
    clear_has_shards();
    ::bedrock::metaserver::ShardRange* temp = shards_.shard_range_;
    shards_.shard_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetShardRoutesRequest::unsafe_arena_set_allocated_shard_range(::bedrock::metaserver::ShardRange* shard_range) {
  clear_shards();
  if (shard_range) {
    set_has_shard_range();
    shards_.shard_range_ = shard_range;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bedrock.metaserver.GetShardRoutesRequest.shard_range)
}
inline ::bedrock::metaserver::ShardRange* GetShardRoutesRequest::_internal_mutable_shard_range() {
  if (!_internal_has_shard_range()) {
    clear_shards();
    set_has_shard_range();
    shards_.shard_range_ = CreateMaybeMessage< ::bedrock::metaserver::ShardRange >(GetArenaForAllocation());
  }
  return shards_.shard_range_;
}
inline ::bedrock::metaserver::ShardRange* GetShardRoutesRequest::mutable_shard_range() {
  ::bedrock::metaserver::ShardRange* _msg = _internal_mutable_shard_range();
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.GetShardRoutesRequest.shard_range)
  return _msg;
}

// .google.protobuf.Timestamp timestamp = 3;
inline bool GetShardRoutesRequest::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool GetShardRoutesRequest::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetShardRoutesRequest::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetShardRoutesRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.GetShardRoutesRequest.timestamp)
  return _internal_timestamp();
}
inline void GetShardRoutesRequest::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bedrock.metaserver.GetShardRoutesRequest.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetShardRoutesRequest::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetShardRoutesRequest::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:bedrock.metaserver.GetShardRoutesRequest.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetShardRoutesRequest::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    timestamp_ = p;
  }
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetShardRoutesRequest::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.GetShardRoutesRequest.timestamp)
  return _msg;
}
inline void GetShardRoutesRequest::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:bedrock.metaserver.GetShardRoutesRequest.timestamp)
}

inline bool GetShardRoutesRequest::has_shards() const {
  return shards_case() != SHARDS_NOT_SET;
}
inline void GetShardRoutesRequest::clear_has_shards() {
  _oneof_case_[0] = SHARDS_NOT_SET;
}
inline GetShardRoutesRequest::ShardsCase GetShardRoutesRequest::shards_case() const {
  return GetShardRoutesRequest::ShardsCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetShardRoutesResponse

// repeated .bedrock.metaserver.RouteRecord routes = 1;
inline int GetShardRoutesResponse::_internal_routes_size() const {
  return routes_.size();
}
inline int GetShardRoutesResponse::routes_size() const {
  return _internal_routes_size();
}
inline void GetShardRoutesResponse::clear_routes() {
  routes_.Clear();
}
inline ::bedrock::metaserver::RouteRecord* GetShardRoutesResponse::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.GetShardRoutesResponse.routes)
  return routes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bedrock::metaserver::RouteRecord >*
GetShardRoutesResponse::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:bedrock.metaserver.GetShardRoutesResponse.routes)
  return &routes_;
}
inline const ::bedrock::metaserver::RouteRecord& GetShardRoutesResponse::_internal_routes(int index) const {
  return routes_.Get(index);
}
inline const ::bedrock::metaserver::RouteRecord& GetShardRoutesResponse::routes(int index) const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.GetShardRoutesResponse.routes)
  return _internal_routes(index);
}
inline ::bedrock::metaserver::RouteRecord* GetShardRoutesResponse::_internal_add_routes() {
  return routes_.Add();
}
inline ::bedrock::metaserver::RouteRecord* GetShardRoutesResponse::add_routes() {
  ::bedrock::metaserver::RouteRecord* _add = _internal_add_routes();
  // @@protoc_insertion_point(field_add:bedrock.metaserver.GetShardRoutesResponse.routes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bedrock::metaserver::RouteRecord >&
GetShardRoutesResponse::routes() const {
  // @@protoc_insertion_point(field_list:bedrock.metaserver.GetShardRoutesResponse.routes)
  return routes_;
}

// -------------------------------------------------------------------

// GetShardRoutesByStorageRequest

// uint64 storage_id = 1;
inline void GetShardRoutesByStorageRequest::clear_storage_id() {
  storage_id_ = uint64_t{0u};
}
inline uint64_t GetShardRoutesByStorageRequest::_internal_storage_id() const {
  return storage_id_;
}
inline uint64_t GetShardRoutesByStorageRequest::storage_id() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.GetShardRoutesByStorageRequest.storage_id)
  return _internal_storage_id();
}
inline void GetShardRoutesByStorageRequest::_internal_set_storage_id(uint64_t value) {
  
  storage_id_ = value;
}
inline void GetShardRoutesByStorageRequest::set_storage_id(uint64_t value) {
  _internal_set_storage_id(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.GetShardRoutesByStorageRequest.storage_id)
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool GetShardRoutesByStorageRequest::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool GetShardRoutesByStorageRequest::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetShardRoutesByStorageRequest::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetShardRoutesByStorageRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.GetShardRoutesByStorageRequest.timestamp)
  return _internal_timestamp();
}
inline void GetShardRoutesByStorageRequest::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bedrock.metaserver.GetShardRoutesByStorageRequest.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetShardRoutesByStorageRequest::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetShardRoutesByStorageRequest::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:bedrock.metaserver.GetShardRoutesByStorageRequest.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetShardRoutesByStorageRequest::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    timestamp_ = p;
  }
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetShardRoutesByStorageRequest::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.GetShardRoutesByStorageRequest.timestamp)
  return _msg;
}
inline void GetShardRoutesByStorageRequest::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:bedrock.metaserver.GetShardRoutesByStorageRequest.timestamp)
}

// -------------------------------------------------------------------

// GetShardRoutesByStorageResponse

// repeated .bedrock.metaserver.RouteRecord routes = 1;
inline int GetShardRoutesByStorageResponse::_internal_routes_size() const {
  return routes_.size();
}
inline int GetShardRoutesByStorageResponse::routes_size() const {
  return _internal_routes_size();
}
inline void GetShardRoutesByStorageResponse::clear_routes() {
  routes_.Clear();
}
inline ::bedrock::metaserver::RouteRecord* GetShardRoutesByStorageResponse::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.GetShardRoutesByStorageResponse.routes)
  return routes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bedrock::metaserver::RouteRecord >*
GetShardRoutesByStorageResponse::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:bedrock.metaserver.GetShardRoutesByStorageResponse.routes)
  return &routes_;
}
inline const ::bedrock::metaserver::RouteRecord& GetShardRoutesByStorageResponse::_internal_routes(int index) const {
  return routes_.Get(index);
}
inline const ::bedrock::metaserver::RouteRecord& GetShardRoutesByStorageResponse::routes(int index) const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.GetShardRoutesByStorageResponse.routes)
  return _internal_routes(index);
}
inline ::bedrock::metaserver::RouteRecord* GetShardRoutesByStorageResponse::_internal_add_routes() {
  return routes_.Add();
}
inline ::bedrock::metaserver::RouteRecord* GetShardRoutesByStorageResponse::add_routes() {
  ::bedrock::metaserver::RouteRecord* _add = _internal_add_routes();
  // @@protoc_insertion_point(field_add:bedrock.metaserver.GetShardRoutesByStorageResponse.routes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bedrock::metaserver::RouteRecord >&
GetShardRoutesByStorageResponse::routes() const {
  // @@protoc_insertion_point(field_list:bedrock.metaserver.GetShardRoutesByStorageResponse.routes)
  return routes_;
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool GetShardRoutesByStorageResponse::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool GetShardRoutesByStorageResponse::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetShardRoutesByStorageResponse::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetShardRoutesByStorageResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.GetShardRoutesByStorageResponse.timestamp)
  return _internal_timestamp();
}
inline void GetShardRoutesByStorageResponse::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bedrock.metaserver.GetShardRoutesByStorageResponse.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetShardRoutesByStorageResponse::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetShardRoutesByStorageResponse::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:bedrock.metaserver.GetShardRoutesByStorageResponse.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetShardRoutesByStorageResponse::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    timestamp_ = p;
  }
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetShardRoutesByStorageResponse::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.GetShardRoutesByStorageResponse.timestamp)
  return _msg;
}
inline void GetShardRoutesByStorageResponse::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:bedrock.metaserver.GetShardRoutesByStorageResponse.timestamp)
}

// bool is_full = 3;
inline void GetShardRoutesByStorageResponse::clear_is_full() {
  is_full_ = false;
}
inline bool GetShardRoutesByStorageResponse::_internal_is_full() const {
  return is_full_;
}
inline bool GetShardRoutesByStorageResponse::is_full() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.GetShardRoutesByStorageResponse.is_full)
  return _internal_is_full();
}
inline void GetShardRoutesByStorageResponse::_internal_set_is_full(bool value) {
  
  is_full_ = value;
}
inline void GetShardRoutesByStorageResponse::set_is_full(bool value) {
  _internal_set_is_full(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.GetShardRoutesByStorageResponse.is_full)
}

// -------------------------------------------------------------------

// AddDataServerRequest

// string addr = 1;
inline void AddDataServerRequest::clear_addr() {
  addr_.ClearToEmpty();
}
inline const std::string& AddDataServerRequest::addr() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.AddDataServerRequest.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddDataServerRequest::set_addr(ArgT0&& arg0, ArgT... args) {
 
 addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bedrock.metaserver.AddDataServerRequest.addr)
}
inline std::string* AddDataServerRequest::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.AddDataServerRequest.addr)
  return _s;
}
inline const std::string& AddDataServerRequest::_internal_addr() const {
  return addr_.Get();
}
inline void AddDataServerRequest::_internal_set_addr(const std::string& value) {
  
  addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddDataServerRequest::_internal_mutable_addr() {
  
  return addr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddDataServerRequest::release_addr() {
  // @@protoc_insertion_point(field_release:bedrock.metaserver.AddDataServerRequest.addr)
  return addr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddDataServerRequest::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (addr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bedrock.metaserver.AddDataServerRequest.addr)
}

// -------------------------------------------------------------------

// AddDataServerResponse

// -------------------------------------------------------------------

// RemoveDataServerRequest

// string addr = 1;
inline void RemoveDataServerRequest::clear_addr() {
  addr_.ClearToEmpty();
}
inline const std::string& RemoveDataServerRequest::addr() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.RemoveDataServerRequest.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveDataServerRequest::set_addr(ArgT0&& arg0, ArgT... args) {
 
 addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bedrock.metaserver.RemoveDataServerRequest.addr)
}
inline std::string* RemoveDataServerRequest::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.RemoveDataServerRequest.addr)
  return _s;
}
inline const std::string& RemoveDataServerRequest::_internal_addr() const {
  return addr_.Get();
}
inline void RemoveDataServerRequest::_internal_set_addr(const std::string& value) {
  
  addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RemoveDataServerRequest::_internal_mutable_addr() {
  
  return addr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RemoveDataServerRequest::release_addr() {
  // @@protoc_insertion_point(field_release:bedrock.metaserver.RemoveDataServerRequest.addr)
  return addr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RemoveDataServerRequest::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (addr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bedrock.metaserver.RemoveDataServerRequest.addr)
}

// -------------------------------------------------------------------

// RemoveDataServerResponse

// -------------------------------------------------------------------

// ListDataServerRequest

// -------------------------------------------------------------------

// ListDataServerResponse

// repeated .bedrock.metaserver.DataServer data_servers = 1;
inline int ListDataServerResponse::_internal_data_servers_size() const {
  return data_servers_.size();
}
inline int ListDataServerResponse::data_servers_size() const {
  return _internal_data_servers_size();
}
inline void ListDataServerResponse::clear_data_servers() {
  data_servers_.Clear();
}
inline ::bedrock::metaserver::DataServer* ListDataServerResponse::mutable_data_servers(int index) {
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.ListDataServerResponse.data_servers)
  return data_servers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bedrock::metaserver::DataServer >*
ListDataServerResponse::mutable_data_servers() {
  // @@protoc_insertion_point(field_mutable_list:bedrock.metaserver.ListDataServerResponse.data_servers)
  return &data_servers_;
}
inline const ::bedrock::metaserver::DataServer& ListDataServerResponse::_internal_data_servers(int index) const {
  return data_servers_.Get(index);
}
inline const ::bedrock::metaserver::DataServer& ListDataServerResponse::data_servers(int index) const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.ListDataServerResponse.data_servers)
  return _internal_data_servers(index);
}
inline ::bedrock::metaserver::DataServer* ListDataServerResponse::_internal_add_data_servers() {
  return data_servers_.Add();
}
inline ::bedrock::metaserver::DataServer* ListDataServerResponse::add_data_servers() {
  ::bedrock::metaserver::DataServer* _add = _internal_add_data_servers();
  // @@protoc_insertion_point(field_add:bedrock.metaserver.ListDataServerResponse.data_servers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bedrock::metaserver::DataServer >&
ListDataServerResponse::data_servers() const {
  // @@protoc_insertion_point(field_list:bedrock.metaserver.ListDataServerResponse.data_servers)
  return data_servers_;
}

// -------------------------------------------------------------------

// UpdateDataServerRequest

// -------------------------------------------------------------------

// UpdateDataServerResponse

// -------------------------------------------------------------------

// ShardInfoRequest

// uint64 id = 1;
inline void ShardInfoRequest::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t ShardInfoRequest::_internal_id() const {
  return id_;
}
inline uint64_t ShardInfoRequest::id() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.ShardInfoRequest.id)
  return _internal_id();
}
inline void ShardInfoRequest::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void ShardInfoRequest::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:bedrock.metaserver.ShardInfoRequest.id)
}

// -------------------------------------------------------------------

// ShardInfoResponse

// .bedrock.metaserver.Shard shard = 1;
inline bool ShardInfoResponse::_internal_has_shard() const {
  return this != internal_default_instance() && shard_ != nullptr;
}
inline bool ShardInfoResponse::has_shard() const {
  return _internal_has_shard();
}
inline void ShardInfoResponse::clear_shard() {
  if (GetArenaForAllocation() == nullptr && shard_ != nullptr) {
    delete shard_;
  }
  shard_ = nullptr;
}
inline const ::bedrock::metaserver::Shard& ShardInfoResponse::_internal_shard() const {
  const ::bedrock::metaserver::Shard* p = shard_;
  return p != nullptr ? *p : reinterpret_cast<const ::bedrock::metaserver::Shard&>(
      ::bedrock::metaserver::_Shard_default_instance_);
}
inline const ::bedrock::metaserver::Shard& ShardInfoResponse::shard() const {
  // @@protoc_insertion_point(field_get:bedrock.metaserver.ShardInfoResponse.shard)
  return _internal_shard();
}
inline void ShardInfoResponse::unsafe_arena_set_allocated_shard(
    ::bedrock::metaserver::Shard* shard) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(shard_);
  }
  shard_ = shard;
  if (shard) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bedrock.metaserver.ShardInfoResponse.shard)
}
inline ::bedrock::metaserver::Shard* ShardInfoResponse::release_shard() {
  
  ::bedrock::metaserver::Shard* temp = shard_;
  shard_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bedrock::metaserver::Shard* ShardInfoResponse::unsafe_arena_release_shard() {
  // @@protoc_insertion_point(field_release:bedrock.metaserver.ShardInfoResponse.shard)
  
  ::bedrock::metaserver::Shard* temp = shard_;
  shard_ = nullptr;
  return temp;
}
inline ::bedrock::metaserver::Shard* ShardInfoResponse::_internal_mutable_shard() {
  
  if (shard_ == nullptr) {
    auto* p = CreateMaybeMessage<::bedrock::metaserver::Shard>(GetArenaForAllocation());
    shard_ = p;
  }
  return shard_;
}
inline ::bedrock::metaserver::Shard* ShardInfoResponse::mutable_shard() {
  ::bedrock::metaserver::Shard* _msg = _internal_mutable_shard();
  // @@protoc_insertion_point(field_mutable:bedrock.metaserver.ShardInfoResponse.shard)
  return _msg;
}
inline void ShardInfoResponse::set_allocated_shard(::bedrock::metaserver::Shard* shard) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete shard_;
  }
  if (shard) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bedrock::metaserver::Shard>::GetOwningArena(shard);
    if (message_arena != submessage_arena) {
      shard = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shard, submessage_arena);
    }
    
  } else {
    
  }
  shard_ = shard;
  // @@protoc_insertion_point(field_set_allocated:bedrock.metaserver.ShardInfoResponse.shard)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace metaserver
}  // namespace bedrock

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_metaserver_2eproto
