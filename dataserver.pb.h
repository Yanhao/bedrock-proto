// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dataserver.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_dataserver_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_dataserver_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_dataserver_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_dataserver_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_dataserver_2eproto;
namespace bedrock {
namespace dataserver {
class AddShardReplicaRequest;
struct AddShardReplicaRequestDefaultTypeInternal;
extern AddShardReplicaRequestDefaultTypeInternal _AddShardReplicaRequest_default_instance_;
class AddShardReplicaResponse;
struct AddShardReplicaResponseDefaultTypeInternal;
extern AddShardReplicaResponseDefaultTypeInternal _AddShardReplicaResponse_default_instance_;
class CreateShardRequest;
struct CreateShardRequestDefaultTypeInternal;
extern CreateShardRequestDefaultTypeInternal _CreateShardRequest_default_instance_;
class CreateShardResponse;
struct CreateShardResponseDefaultTypeInternal;
extern CreateShardResponseDefaultTypeInternal _CreateShardResponse_default_instance_;
class DataServerJoinRequest;
struct DataServerJoinRequestDefaultTypeInternal;
extern DataServerJoinRequestDefaultTypeInternal _DataServerJoinRequest_default_instance_;
class DataServerJoinResponse;
struct DataServerJoinResponseDefaultTypeInternal;
extern DataServerJoinResponseDefaultTypeInternal _DataServerJoinResponse_default_instance_;
class DataServerLeaveRequest;
struct DataServerLeaveRequestDefaultTypeInternal;
extern DataServerLeaveRequestDefaultTypeInternal _DataServerLeaveRequest_default_instance_;
class DataServerLeaveResponse;
struct DataServerLeaveResponseDefaultTypeInternal;
extern DataServerLeaveResponseDefaultTypeInternal _DataServerLeaveResponse_default_instance_;
class DeleteShardReplicaRequest;
struct DeleteShardReplicaRequestDefaultTypeInternal;
extern DeleteShardReplicaRequestDefaultTypeInternal _DeleteShardReplicaRequest_default_instance_;
class DeleteShardReplicaResponse;
struct DeleteShardReplicaResponseDefaultTypeInternal;
extern DeleteShardReplicaResponseDefaultTypeInternal _DeleteShardReplicaResponse_default_instance_;
class DeleteShardRequest;
struct DeleteShardRequestDefaultTypeInternal;
extern DeleteShardRequestDefaultTypeInternal _DeleteShardRequest_default_instance_;
class DeleteShardResponse;
struct DeleteShardResponseDefaultTypeInternal;
extern DeleteShardResponseDefaultTypeInternal _DeleteShardResponse_default_instance_;
class LockShardRequest;
struct LockShardRequestDefaultTypeInternal;
extern LockShardRequestDefaultTypeInternal _LockShardRequest_default_instance_;
class LockShardResponse;
struct LockShardResponseDefaultTypeInternal;
extern LockShardResponseDefaultTypeInternal _LockShardResponse_default_instance_;
class MergeShardRequest;
struct MergeShardRequestDefaultTypeInternal;
extern MergeShardRequestDefaultTypeInternal _MergeShardRequest_default_instance_;
class MergeShardResponse;
struct MergeShardResponseDefaultTypeInternal;
extern MergeShardResponseDefaultTypeInternal _MergeShardResponse_default_instance_;
class PullShardDataRequest;
struct PullShardDataRequestDefaultTypeInternal;
extern PullShardDataRequestDefaultTypeInternal _PullShardDataRequest_default_instance_;
class PullShardDataResponse;
struct PullShardDataResponseDefaultTypeInternal;
extern PullShardDataResponseDefaultTypeInternal _PullShardDataResponse_default_instance_;
class ShardAppendLogRequest;
struct ShardAppendLogRequestDefaultTypeInternal;
extern ShardAppendLogRequestDefaultTypeInternal _ShardAppendLogRequest_default_instance_;
class ShardAppendLogRequest_Entry;
struct ShardAppendLogRequest_EntryDefaultTypeInternal;
extern ShardAppendLogRequest_EntryDefaultTypeInternal _ShardAppendLogRequest_Entry_default_instance_;
class ShardAppendLogResponse;
struct ShardAppendLogResponseDefaultTypeInternal;
extern ShardAppendLogResponseDefaultTypeInternal _ShardAppendLogResponse_default_instance_;
class ShardInstallSnapshotRequest;
struct ShardInstallSnapshotRequestDefaultTypeInternal;
extern ShardInstallSnapshotRequestDefaultTypeInternal _ShardInstallSnapshotRequest_default_instance_;
class ShardInstallSnapshotResponse;
struct ShardInstallSnapshotResponseDefaultTypeInternal;
extern ShardInstallSnapshotResponseDefaultTypeInternal _ShardInstallSnapshotResponse_default_instance_;
class ShardMeta;
struct ShardMetaDefaultTypeInternal;
extern ShardMetaDefaultTypeInternal _ShardMeta_default_instance_;
class ShardReadRequest;
struct ShardReadRequestDefaultTypeInternal;
extern ShardReadRequestDefaultTypeInternal _ShardReadRequest_default_instance_;
class ShardReadResponse;
struct ShardReadResponseDefaultTypeInternal;
extern ShardReadResponseDefaultTypeInternal _ShardReadResponse_default_instance_;
class ShardRepairRequest;
struct ShardRepairRequestDefaultTypeInternal;
extern ShardRepairRequestDefaultTypeInternal _ShardRepairRequest_default_instance_;
class ShardRepairResponse;
struct ShardRepairResponseDefaultTypeInternal;
extern ShardRepairResponseDefaultTypeInternal _ShardRepairResponse_default_instance_;
class ShardWriteReplicaRequest;
struct ShardWriteReplicaRequestDefaultTypeInternal;
extern ShardWriteReplicaRequestDefaultTypeInternal _ShardWriteReplicaRequest_default_instance_;
class ShardWriteReplicaResponse;
struct ShardWriteReplicaResponseDefaultTypeInternal;
extern ShardWriteReplicaResponseDefaultTypeInternal _ShardWriteReplicaResponse_default_instance_;
class ShardWriteRequest;
struct ShardWriteRequestDefaultTypeInternal;
extern ShardWriteRequestDefaultTypeInternal _ShardWriteRequest_default_instance_;
class ShardWriteResponse;
struct ShardWriteResponseDefaultTypeInternal;
extern ShardWriteResponseDefaultTypeInternal _ShardWriteResponse_default_instance_;
class SplitShardRequest;
struct SplitShardRequestDefaultTypeInternal;
extern SplitShardRequestDefaultTypeInternal _SplitShardRequest_default_instance_;
class SplitShardResponse;
struct SplitShardResponseDefaultTypeInternal;
extern SplitShardResponseDefaultTypeInternal _SplitShardResponse_default_instance_;
class TransferShardLeaderRequest;
struct TransferShardLeaderRequestDefaultTypeInternal;
extern TransferShardLeaderRequestDefaultTypeInternal _TransferShardLeaderRequest_default_instance_;
class TransferShardLeaderResponse;
struct TransferShardLeaderResponseDefaultTypeInternal;
extern TransferShardLeaderResponseDefaultTypeInternal _TransferShardLeaderResponse_default_instance_;
class TransferShardRequest;
struct TransferShardRequestDefaultTypeInternal;
extern TransferShardRequestDefaultTypeInternal _TransferShardRequest_default_instance_;
class TransferShardResponse;
struct TransferShardResponseDefaultTypeInternal;
extern TransferShardResponseDefaultTypeInternal _TransferShardResponse_default_instance_;
class UnlockShardRequest;
struct UnlockShardRequestDefaultTypeInternal;
extern UnlockShardRequestDefaultTypeInternal _UnlockShardRequest_default_instance_;
class UnlockShardResponse;
struct UnlockShardResponseDefaultTypeInternal;
extern UnlockShardResponseDefaultTypeInternal _UnlockShardResponse_default_instance_;
}  // namespace dataserver
}  // namespace bedrock
PROTOBUF_NAMESPACE_OPEN
template<> ::bedrock::dataserver::AddShardReplicaRequest* Arena::CreateMaybeMessage<::bedrock::dataserver::AddShardReplicaRequest>(Arena*);
template<> ::bedrock::dataserver::AddShardReplicaResponse* Arena::CreateMaybeMessage<::bedrock::dataserver::AddShardReplicaResponse>(Arena*);
template<> ::bedrock::dataserver::CreateShardRequest* Arena::CreateMaybeMessage<::bedrock::dataserver::CreateShardRequest>(Arena*);
template<> ::bedrock::dataserver::CreateShardResponse* Arena::CreateMaybeMessage<::bedrock::dataserver::CreateShardResponse>(Arena*);
template<> ::bedrock::dataserver::DataServerJoinRequest* Arena::CreateMaybeMessage<::bedrock::dataserver::DataServerJoinRequest>(Arena*);
template<> ::bedrock::dataserver::DataServerJoinResponse* Arena::CreateMaybeMessage<::bedrock::dataserver::DataServerJoinResponse>(Arena*);
template<> ::bedrock::dataserver::DataServerLeaveRequest* Arena::CreateMaybeMessage<::bedrock::dataserver::DataServerLeaveRequest>(Arena*);
template<> ::bedrock::dataserver::DataServerLeaveResponse* Arena::CreateMaybeMessage<::bedrock::dataserver::DataServerLeaveResponse>(Arena*);
template<> ::bedrock::dataserver::DeleteShardReplicaRequest* Arena::CreateMaybeMessage<::bedrock::dataserver::DeleteShardReplicaRequest>(Arena*);
template<> ::bedrock::dataserver::DeleteShardReplicaResponse* Arena::CreateMaybeMessage<::bedrock::dataserver::DeleteShardReplicaResponse>(Arena*);
template<> ::bedrock::dataserver::DeleteShardRequest* Arena::CreateMaybeMessage<::bedrock::dataserver::DeleteShardRequest>(Arena*);
template<> ::bedrock::dataserver::DeleteShardResponse* Arena::CreateMaybeMessage<::bedrock::dataserver::DeleteShardResponse>(Arena*);
template<> ::bedrock::dataserver::LockShardRequest* Arena::CreateMaybeMessage<::bedrock::dataserver::LockShardRequest>(Arena*);
template<> ::bedrock::dataserver::LockShardResponse* Arena::CreateMaybeMessage<::bedrock::dataserver::LockShardResponse>(Arena*);
template<> ::bedrock::dataserver::MergeShardRequest* Arena::CreateMaybeMessage<::bedrock::dataserver::MergeShardRequest>(Arena*);
template<> ::bedrock::dataserver::MergeShardResponse* Arena::CreateMaybeMessage<::bedrock::dataserver::MergeShardResponse>(Arena*);
template<> ::bedrock::dataserver::PullShardDataRequest* Arena::CreateMaybeMessage<::bedrock::dataserver::PullShardDataRequest>(Arena*);
template<> ::bedrock::dataserver::PullShardDataResponse* Arena::CreateMaybeMessage<::bedrock::dataserver::PullShardDataResponse>(Arena*);
template<> ::bedrock::dataserver::ShardAppendLogRequest* Arena::CreateMaybeMessage<::bedrock::dataserver::ShardAppendLogRequest>(Arena*);
template<> ::bedrock::dataserver::ShardAppendLogRequest_Entry* Arena::CreateMaybeMessage<::bedrock::dataserver::ShardAppendLogRequest_Entry>(Arena*);
template<> ::bedrock::dataserver::ShardAppendLogResponse* Arena::CreateMaybeMessage<::bedrock::dataserver::ShardAppendLogResponse>(Arena*);
template<> ::bedrock::dataserver::ShardInstallSnapshotRequest* Arena::CreateMaybeMessage<::bedrock::dataserver::ShardInstallSnapshotRequest>(Arena*);
template<> ::bedrock::dataserver::ShardInstallSnapshotResponse* Arena::CreateMaybeMessage<::bedrock::dataserver::ShardInstallSnapshotResponse>(Arena*);
template<> ::bedrock::dataserver::ShardMeta* Arena::CreateMaybeMessage<::bedrock::dataserver::ShardMeta>(Arena*);
template<> ::bedrock::dataserver::ShardReadRequest* Arena::CreateMaybeMessage<::bedrock::dataserver::ShardReadRequest>(Arena*);
template<> ::bedrock::dataserver::ShardReadResponse* Arena::CreateMaybeMessage<::bedrock::dataserver::ShardReadResponse>(Arena*);
template<> ::bedrock::dataserver::ShardRepairRequest* Arena::CreateMaybeMessage<::bedrock::dataserver::ShardRepairRequest>(Arena*);
template<> ::bedrock::dataserver::ShardRepairResponse* Arena::CreateMaybeMessage<::bedrock::dataserver::ShardRepairResponse>(Arena*);
template<> ::bedrock::dataserver::ShardWriteReplicaRequest* Arena::CreateMaybeMessage<::bedrock::dataserver::ShardWriteReplicaRequest>(Arena*);
template<> ::bedrock::dataserver::ShardWriteReplicaResponse* Arena::CreateMaybeMessage<::bedrock::dataserver::ShardWriteReplicaResponse>(Arena*);
template<> ::bedrock::dataserver::ShardWriteRequest* Arena::CreateMaybeMessage<::bedrock::dataserver::ShardWriteRequest>(Arena*);
template<> ::bedrock::dataserver::ShardWriteResponse* Arena::CreateMaybeMessage<::bedrock::dataserver::ShardWriteResponse>(Arena*);
template<> ::bedrock::dataserver::SplitShardRequest* Arena::CreateMaybeMessage<::bedrock::dataserver::SplitShardRequest>(Arena*);
template<> ::bedrock::dataserver::SplitShardResponse* Arena::CreateMaybeMessage<::bedrock::dataserver::SplitShardResponse>(Arena*);
template<> ::bedrock::dataserver::TransferShardLeaderRequest* Arena::CreateMaybeMessage<::bedrock::dataserver::TransferShardLeaderRequest>(Arena*);
template<> ::bedrock::dataserver::TransferShardLeaderResponse* Arena::CreateMaybeMessage<::bedrock::dataserver::TransferShardLeaderResponse>(Arena*);
template<> ::bedrock::dataserver::TransferShardRequest* Arena::CreateMaybeMessage<::bedrock::dataserver::TransferShardRequest>(Arena*);
template<> ::bedrock::dataserver::TransferShardResponse* Arena::CreateMaybeMessage<::bedrock::dataserver::TransferShardResponse>(Arena*);
template<> ::bedrock::dataserver::UnlockShardRequest* Arena::CreateMaybeMessage<::bedrock::dataserver::UnlockShardRequest>(Arena*);
template<> ::bedrock::dataserver::UnlockShardResponse* Arena::CreateMaybeMessage<::bedrock::dataserver::UnlockShardResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bedrock {
namespace dataserver {

// ===================================================================

class ShardMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.dataserver.ShardMeta) */ {
 public:
  inline ShardMeta() : ShardMeta(nullptr) {}
  ~ShardMeta() override;
  explicit PROTOBUF_CONSTEXPR ShardMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShardMeta(const ShardMeta& from);
  ShardMeta(ShardMeta&& from) noexcept
    : ShardMeta() {
    *this = ::std::move(from);
  }

  inline ShardMeta& operator=(const ShardMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardMeta& operator=(ShardMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShardMeta* internal_default_instance() {
    return reinterpret_cast<const ShardMeta*>(
               &_ShardMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ShardMeta& a, ShardMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(ShardMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShardMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShardMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShardMeta& from) {
    ShardMeta::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShardMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.ShardMeta";
  }
  protected:
  explicit ShardMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplicatesFieldNumber = 4,
    kLeaderFieldNumber = 7,
    kCreateTsFieldNumber = 3,
    kReplicatesUpdateTsFieldNumber = 5,
    kLeaderChangeTsFieldNumber = 8,
    kShardIdFieldNumber = 1,
    kStorageIdFieldNumber = 2,
    kLastWalIndexFieldNumber = 9,
    kIsLeaderFieldNumber = 6,
  };
  // repeated string replicates = 4;
  int replicates_size() const;
  private:
  int _internal_replicates_size() const;
  public:
  void clear_replicates();
  const std::string& replicates(int index) const;
  std::string* mutable_replicates(int index);
  void set_replicates(int index, const std::string& value);
  void set_replicates(int index, std::string&& value);
  void set_replicates(int index, const char* value);
  void set_replicates(int index, const char* value, size_t size);
  std::string* add_replicates();
  void add_replicates(const std::string& value);
  void add_replicates(std::string&& value);
  void add_replicates(const char* value);
  void add_replicates(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& replicates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_replicates();
  private:
  const std::string& _internal_replicates(int index) const;
  std::string* _internal_add_replicates();
  public:

  // string leader = 7;
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_NODISCARD std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // .google.protobuf.Timestamp create_ts = 3;
  bool has_create_ts() const;
  private:
  bool _internal_has_create_ts() const;
  public:
  void clear_create_ts();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& create_ts() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_create_ts();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_create_ts();
  void set_allocated_create_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* create_ts);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_create_ts() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_create_ts();
  public:
  void unsafe_arena_set_allocated_create_ts(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* create_ts);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_create_ts();

  // .google.protobuf.Timestamp replicates_update_ts = 5;
  bool has_replicates_update_ts() const;
  private:
  bool _internal_has_replicates_update_ts() const;
  public:
  void clear_replicates_update_ts();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& replicates_update_ts() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_replicates_update_ts();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_replicates_update_ts();
  void set_allocated_replicates_update_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* replicates_update_ts);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_replicates_update_ts() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_replicates_update_ts();
  public:
  void unsafe_arena_set_allocated_replicates_update_ts(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* replicates_update_ts);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_replicates_update_ts();

  // .google.protobuf.Timestamp leader_change_ts = 8;
  bool has_leader_change_ts() const;
  private:
  bool _internal_has_leader_change_ts() const;
  public:
  void clear_leader_change_ts();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& leader_change_ts() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_leader_change_ts();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_leader_change_ts();
  void set_allocated_leader_change_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* leader_change_ts);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_leader_change_ts() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_leader_change_ts();
  public:
  void unsafe_arena_set_allocated_leader_change_ts(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* leader_change_ts);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_leader_change_ts();

  // uint64 shard_id = 1;
  void clear_shard_id();
  uint64_t shard_id() const;
  void set_shard_id(uint64_t value);
  private:
  uint64_t _internal_shard_id() const;
  void _internal_set_shard_id(uint64_t value);
  public:

  // uint64 storage_id = 2;
  void clear_storage_id();
  uint64_t storage_id() const;
  void set_storage_id(uint64_t value);
  private:
  uint64_t _internal_storage_id() const;
  void _internal_set_storage_id(uint64_t value);
  public:

  // uint64 last_wal_index = 9;
  void clear_last_wal_index();
  uint64_t last_wal_index() const;
  void set_last_wal_index(uint64_t value);
  private:
  uint64_t _internal_last_wal_index() const;
  void _internal_set_last_wal_index(uint64_t value);
  public:

  // bool is_leader = 6;
  void clear_is_leader();
  bool is_leader() const;
  void set_is_leader(bool value);
  private:
  bool _internal_is_leader() const;
  void _internal_set_is_leader(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.ShardMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> replicates_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_ts_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* replicates_update_ts_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* leader_change_ts_;
    uint64_t shard_id_;
    uint64_t storage_id_;
    uint64_t last_wal_index_;
    bool is_leader_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class SplitShardRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.SplitShardRequest) */ {
 public:
  inline SplitShardRequest() : SplitShardRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SplitShardRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SplitShardRequest(const SplitShardRequest& from);
  SplitShardRequest(SplitShardRequest&& from) noexcept
    : SplitShardRequest() {
    *this = ::std::move(from);
  }

  inline SplitShardRequest& operator=(const SplitShardRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SplitShardRequest& operator=(SplitShardRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SplitShardRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SplitShardRequest* internal_default_instance() {
    return reinterpret_cast<const SplitShardRequest*>(
               &_SplitShardRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SplitShardRequest& a, SplitShardRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SplitShardRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SplitShardRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SplitShardRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SplitShardRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SplitShardRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SplitShardRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.SplitShardRequest";
  }
  protected:
  explicit SplitShardRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.SplitShardRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class SplitShardResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.SplitShardResponse) */ {
 public:
  inline SplitShardResponse() : SplitShardResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SplitShardResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SplitShardResponse(const SplitShardResponse& from);
  SplitShardResponse(SplitShardResponse&& from) noexcept
    : SplitShardResponse() {
    *this = ::std::move(from);
  }

  inline SplitShardResponse& operator=(const SplitShardResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SplitShardResponse& operator=(SplitShardResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SplitShardResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SplitShardResponse* internal_default_instance() {
    return reinterpret_cast<const SplitShardResponse*>(
               &_SplitShardResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SplitShardResponse& a, SplitShardResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SplitShardResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SplitShardResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SplitShardResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SplitShardResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SplitShardResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SplitShardResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.SplitShardResponse";
  }
  protected:
  explicit SplitShardResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.SplitShardResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class MergeShardRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.MergeShardRequest) */ {
 public:
  inline MergeShardRequest() : MergeShardRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MergeShardRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MergeShardRequest(const MergeShardRequest& from);
  MergeShardRequest(MergeShardRequest&& from) noexcept
    : MergeShardRequest() {
    *this = ::std::move(from);
  }

  inline MergeShardRequest& operator=(const MergeShardRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MergeShardRequest& operator=(MergeShardRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MergeShardRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MergeShardRequest* internal_default_instance() {
    return reinterpret_cast<const MergeShardRequest*>(
               &_MergeShardRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MergeShardRequest& a, MergeShardRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MergeShardRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MergeShardRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MergeShardRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MergeShardRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MergeShardRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MergeShardRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.MergeShardRequest";
  }
  protected:
  explicit MergeShardRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.MergeShardRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class MergeShardResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.MergeShardResponse) */ {
 public:
  inline MergeShardResponse() : MergeShardResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MergeShardResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MergeShardResponse(const MergeShardResponse& from);
  MergeShardResponse(MergeShardResponse&& from) noexcept
    : MergeShardResponse() {
    *this = ::std::move(from);
  }

  inline MergeShardResponse& operator=(const MergeShardResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MergeShardResponse& operator=(MergeShardResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MergeShardResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MergeShardResponse* internal_default_instance() {
    return reinterpret_cast<const MergeShardResponse*>(
               &_MergeShardResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MergeShardResponse& a, MergeShardResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MergeShardResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MergeShardResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MergeShardResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MergeShardResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MergeShardResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MergeShardResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.MergeShardResponse";
  }
  protected:
  explicit MergeShardResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.MergeShardResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class CreateShardRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.dataserver.CreateShardRequest) */ {
 public:
  inline CreateShardRequest() : CreateShardRequest(nullptr) {}
  ~CreateShardRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateShardRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateShardRequest(const CreateShardRequest& from);
  CreateShardRequest(CreateShardRequest&& from) noexcept
    : CreateShardRequest() {
    *this = ::std::move(from);
  }

  inline CreateShardRequest& operator=(const CreateShardRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateShardRequest& operator=(CreateShardRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateShardRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateShardRequest* internal_default_instance() {
    return reinterpret_cast<const CreateShardRequest*>(
               &_CreateShardRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CreateShardRequest& a, CreateShardRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateShardRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateShardRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateShardRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateShardRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateShardRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateShardRequest& from) {
    CreateShardRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateShardRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.CreateShardRequest";
  }
  protected:
  explicit CreateShardRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplicatesFieldNumber = 4,
    kLeaderFieldNumber = 6,
    kCreateTsFieldNumber = 3,
    kReplicaUpdateTsFieldNumber = 5,
    kLeaderChangeTsFieldNumber = 7,
    kShardIdFieldNumber = 1,
    kStorageIdFieldNumber = 2,
  };
  // repeated string replicates = 4;
  int replicates_size() const;
  private:
  int _internal_replicates_size() const;
  public:
  void clear_replicates();
  const std::string& replicates(int index) const;
  std::string* mutable_replicates(int index);
  void set_replicates(int index, const std::string& value);
  void set_replicates(int index, std::string&& value);
  void set_replicates(int index, const char* value);
  void set_replicates(int index, const char* value, size_t size);
  std::string* add_replicates();
  void add_replicates(const std::string& value);
  void add_replicates(std::string&& value);
  void add_replicates(const char* value);
  void add_replicates(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& replicates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_replicates();
  private:
  const std::string& _internal_replicates(int index) const;
  std::string* _internal_add_replicates();
  public:

  // string leader = 6;
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_NODISCARD std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // .google.protobuf.Timestamp create_ts = 3;
  bool has_create_ts() const;
  private:
  bool _internal_has_create_ts() const;
  public:
  void clear_create_ts();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& create_ts() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_create_ts();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_create_ts();
  void set_allocated_create_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* create_ts);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_create_ts() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_create_ts();
  public:
  void unsafe_arena_set_allocated_create_ts(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* create_ts);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_create_ts();

  // .google.protobuf.Timestamp replica_update_ts = 5;
  bool has_replica_update_ts() const;
  private:
  bool _internal_has_replica_update_ts() const;
  public:
  void clear_replica_update_ts();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& replica_update_ts() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_replica_update_ts();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_replica_update_ts();
  void set_allocated_replica_update_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* replica_update_ts);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_replica_update_ts() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_replica_update_ts();
  public:
  void unsafe_arena_set_allocated_replica_update_ts(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* replica_update_ts);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_replica_update_ts();

  // .google.protobuf.Timestamp leader_change_ts = 7;
  bool has_leader_change_ts() const;
  private:
  bool _internal_has_leader_change_ts() const;
  public:
  void clear_leader_change_ts();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& leader_change_ts() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_leader_change_ts();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_leader_change_ts();
  void set_allocated_leader_change_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* leader_change_ts);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_leader_change_ts() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_leader_change_ts();
  public:
  void unsafe_arena_set_allocated_leader_change_ts(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* leader_change_ts);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_leader_change_ts();

  // uint64 shard_id = 1;
  void clear_shard_id();
  uint64_t shard_id() const;
  void set_shard_id(uint64_t value);
  private:
  uint64_t _internal_shard_id() const;
  void _internal_set_shard_id(uint64_t value);
  public:

  // uint64 storage_id = 2;
  void clear_storage_id();
  uint64_t storage_id() const;
  void set_storage_id(uint64_t value);
  private:
  uint64_t _internal_storage_id() const;
  void _internal_set_storage_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.CreateShardRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> replicates_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_ts_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* replica_update_ts_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* leader_change_ts_;
    uint64_t shard_id_;
    uint64_t storage_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class CreateShardResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.CreateShardResponse) */ {
 public:
  inline CreateShardResponse() : CreateShardResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CreateShardResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateShardResponse(const CreateShardResponse& from);
  CreateShardResponse(CreateShardResponse&& from) noexcept
    : CreateShardResponse() {
    *this = ::std::move(from);
  }

  inline CreateShardResponse& operator=(const CreateShardResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateShardResponse& operator=(CreateShardResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateShardResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateShardResponse* internal_default_instance() {
    return reinterpret_cast<const CreateShardResponse*>(
               &_CreateShardResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CreateShardResponse& a, CreateShardResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateShardResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateShardResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateShardResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateShardResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CreateShardResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CreateShardResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.CreateShardResponse";
  }
  protected:
  explicit CreateShardResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.CreateShardResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class DeleteShardRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.dataserver.DeleteShardRequest) */ {
 public:
  inline DeleteShardRequest() : DeleteShardRequest(nullptr) {}
  ~DeleteShardRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteShardRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteShardRequest(const DeleteShardRequest& from);
  DeleteShardRequest(DeleteShardRequest&& from) noexcept
    : DeleteShardRequest() {
    *this = ::std::move(from);
  }

  inline DeleteShardRequest& operator=(const DeleteShardRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteShardRequest& operator=(DeleteShardRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteShardRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteShardRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteShardRequest*>(
               &_DeleteShardRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DeleteShardRequest& a, DeleteShardRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteShardRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteShardRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteShardRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteShardRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteShardRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteShardRequest& from) {
    DeleteShardRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteShardRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.DeleteShardRequest";
  }
  protected:
  explicit DeleteShardRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShardIdFieldNumber = 1,
  };
  // uint64 shard_id = 1;
  void clear_shard_id();
  uint64_t shard_id() const;
  void set_shard_id(uint64_t value);
  private:
  uint64_t _internal_shard_id() const;
  void _internal_set_shard_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.DeleteShardRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t shard_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class DeleteShardResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.DeleteShardResponse) */ {
 public:
  inline DeleteShardResponse() : DeleteShardResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteShardResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteShardResponse(const DeleteShardResponse& from);
  DeleteShardResponse(DeleteShardResponse&& from) noexcept
    : DeleteShardResponse() {
    *this = ::std::move(from);
  }

  inline DeleteShardResponse& operator=(const DeleteShardResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteShardResponse& operator=(DeleteShardResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteShardResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteShardResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteShardResponse*>(
               &_DeleteShardResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DeleteShardResponse& a, DeleteShardResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteShardResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteShardResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteShardResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteShardResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteShardResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteShardResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.DeleteShardResponse";
  }
  protected:
  explicit DeleteShardResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.DeleteShardResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class PullShardDataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.PullShardDataRequest) */ {
 public:
  inline PullShardDataRequest() : PullShardDataRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR PullShardDataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PullShardDataRequest(const PullShardDataRequest& from);
  PullShardDataRequest(PullShardDataRequest&& from) noexcept
    : PullShardDataRequest() {
    *this = ::std::move(from);
  }

  inline PullShardDataRequest& operator=(const PullShardDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PullShardDataRequest& operator=(PullShardDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PullShardDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PullShardDataRequest* internal_default_instance() {
    return reinterpret_cast<const PullShardDataRequest*>(
               &_PullShardDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PullShardDataRequest& a, PullShardDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PullShardDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PullShardDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PullShardDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PullShardDataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PullShardDataRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PullShardDataRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.PullShardDataRequest";
  }
  protected:
  explicit PullShardDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.PullShardDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class PullShardDataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.PullShardDataResponse) */ {
 public:
  inline PullShardDataResponse() : PullShardDataResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR PullShardDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PullShardDataResponse(const PullShardDataResponse& from);
  PullShardDataResponse(PullShardDataResponse&& from) noexcept
    : PullShardDataResponse() {
    *this = ::std::move(from);
  }

  inline PullShardDataResponse& operator=(const PullShardDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PullShardDataResponse& operator=(PullShardDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PullShardDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PullShardDataResponse* internal_default_instance() {
    return reinterpret_cast<const PullShardDataResponse*>(
               &_PullShardDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PullShardDataResponse& a, PullShardDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PullShardDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PullShardDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PullShardDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PullShardDataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PullShardDataResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PullShardDataResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.PullShardDataResponse";
  }
  protected:
  explicit PullShardDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.PullShardDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class TransferShardRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.TransferShardRequest) */ {
 public:
  inline TransferShardRequest() : TransferShardRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR TransferShardRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferShardRequest(const TransferShardRequest& from);
  TransferShardRequest(TransferShardRequest&& from) noexcept
    : TransferShardRequest() {
    *this = ::std::move(from);
  }

  inline TransferShardRequest& operator=(const TransferShardRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferShardRequest& operator=(TransferShardRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferShardRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferShardRequest* internal_default_instance() {
    return reinterpret_cast<const TransferShardRequest*>(
               &_TransferShardRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TransferShardRequest& a, TransferShardRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferShardRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferShardRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferShardRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferShardRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const TransferShardRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const TransferShardRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.TransferShardRequest";
  }
  protected:
  explicit TransferShardRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.TransferShardRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class TransferShardResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.TransferShardResponse) */ {
 public:
  inline TransferShardResponse() : TransferShardResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR TransferShardResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferShardResponse(const TransferShardResponse& from);
  TransferShardResponse(TransferShardResponse&& from) noexcept
    : TransferShardResponse() {
    *this = ::std::move(from);
  }

  inline TransferShardResponse& operator=(const TransferShardResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferShardResponse& operator=(TransferShardResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferShardResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferShardResponse* internal_default_instance() {
    return reinterpret_cast<const TransferShardResponse*>(
               &_TransferShardResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TransferShardResponse& a, TransferShardResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferShardResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferShardResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferShardResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferShardResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const TransferShardResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const TransferShardResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.TransferShardResponse";
  }
  protected:
  explicit TransferShardResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.TransferShardResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class AddShardReplicaRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.AddShardReplicaRequest) */ {
 public:
  inline AddShardReplicaRequest() : AddShardReplicaRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AddShardReplicaRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddShardReplicaRequest(const AddShardReplicaRequest& from);
  AddShardReplicaRequest(AddShardReplicaRequest&& from) noexcept
    : AddShardReplicaRequest() {
    *this = ::std::move(from);
  }

  inline AddShardReplicaRequest& operator=(const AddShardReplicaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddShardReplicaRequest& operator=(AddShardReplicaRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddShardReplicaRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddShardReplicaRequest* internal_default_instance() {
    return reinterpret_cast<const AddShardReplicaRequest*>(
               &_AddShardReplicaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AddShardReplicaRequest& a, AddShardReplicaRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddShardReplicaRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddShardReplicaRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddShardReplicaRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddShardReplicaRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AddShardReplicaRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AddShardReplicaRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.AddShardReplicaRequest";
  }
  protected:
  explicit AddShardReplicaRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.AddShardReplicaRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class AddShardReplicaResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.AddShardReplicaResponse) */ {
 public:
  inline AddShardReplicaResponse() : AddShardReplicaResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AddShardReplicaResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddShardReplicaResponse(const AddShardReplicaResponse& from);
  AddShardReplicaResponse(AddShardReplicaResponse&& from) noexcept
    : AddShardReplicaResponse() {
    *this = ::std::move(from);
  }

  inline AddShardReplicaResponse& operator=(const AddShardReplicaResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddShardReplicaResponse& operator=(AddShardReplicaResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddShardReplicaResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddShardReplicaResponse* internal_default_instance() {
    return reinterpret_cast<const AddShardReplicaResponse*>(
               &_AddShardReplicaResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AddShardReplicaResponse& a, AddShardReplicaResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AddShardReplicaResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddShardReplicaResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddShardReplicaResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddShardReplicaResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AddShardReplicaResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AddShardReplicaResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.AddShardReplicaResponse";
  }
  protected:
  explicit AddShardReplicaResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.AddShardReplicaResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class DeleteShardReplicaRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.DeleteShardReplicaRequest) */ {
 public:
  inline DeleteShardReplicaRequest() : DeleteShardReplicaRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteShardReplicaRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteShardReplicaRequest(const DeleteShardReplicaRequest& from);
  DeleteShardReplicaRequest(DeleteShardReplicaRequest&& from) noexcept
    : DeleteShardReplicaRequest() {
    *this = ::std::move(from);
  }

  inline DeleteShardReplicaRequest& operator=(const DeleteShardReplicaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteShardReplicaRequest& operator=(DeleteShardReplicaRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteShardReplicaRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteShardReplicaRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteShardReplicaRequest*>(
               &_DeleteShardReplicaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(DeleteShardReplicaRequest& a, DeleteShardReplicaRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteShardReplicaRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteShardReplicaRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteShardReplicaRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteShardReplicaRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteShardReplicaRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteShardReplicaRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.DeleteShardReplicaRequest";
  }
  protected:
  explicit DeleteShardReplicaRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.DeleteShardReplicaRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class DeleteShardReplicaResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.DeleteShardReplicaResponse) */ {
 public:
  inline DeleteShardReplicaResponse() : DeleteShardReplicaResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteShardReplicaResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteShardReplicaResponse(const DeleteShardReplicaResponse& from);
  DeleteShardReplicaResponse(DeleteShardReplicaResponse&& from) noexcept
    : DeleteShardReplicaResponse() {
    *this = ::std::move(from);
  }

  inline DeleteShardReplicaResponse& operator=(const DeleteShardReplicaResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteShardReplicaResponse& operator=(DeleteShardReplicaResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteShardReplicaResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteShardReplicaResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteShardReplicaResponse*>(
               &_DeleteShardReplicaResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(DeleteShardReplicaResponse& a, DeleteShardReplicaResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteShardReplicaResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteShardReplicaResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteShardReplicaResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteShardReplicaResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteShardReplicaResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteShardReplicaResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.DeleteShardReplicaResponse";
  }
  protected:
  explicit DeleteShardReplicaResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.DeleteShardReplicaResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class TransferShardLeaderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.dataserver.TransferShardLeaderRequest) */ {
 public:
  inline TransferShardLeaderRequest() : TransferShardLeaderRequest(nullptr) {}
  ~TransferShardLeaderRequest() override;
  explicit PROTOBUF_CONSTEXPR TransferShardLeaderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferShardLeaderRequest(const TransferShardLeaderRequest& from);
  TransferShardLeaderRequest(TransferShardLeaderRequest&& from) noexcept
    : TransferShardLeaderRequest() {
    *this = ::std::move(from);
  }

  inline TransferShardLeaderRequest& operator=(const TransferShardLeaderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferShardLeaderRequest& operator=(TransferShardLeaderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferShardLeaderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferShardLeaderRequest* internal_default_instance() {
    return reinterpret_cast<const TransferShardLeaderRequest*>(
               &_TransferShardLeaderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(TransferShardLeaderRequest& a, TransferShardLeaderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferShardLeaderRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferShardLeaderRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferShardLeaderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferShardLeaderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransferShardLeaderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransferShardLeaderRequest& from) {
    TransferShardLeaderRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferShardLeaderRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.TransferShardLeaderRequest";
  }
  protected:
  explicit TransferShardLeaderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplicatesFieldNumber = 2,
    kLeaderChangeTsFieldNumber = 3,
    kShardIdFieldNumber = 1,
  };
  // repeated string replicates = 2;
  int replicates_size() const;
  private:
  int _internal_replicates_size() const;
  public:
  void clear_replicates();
  const std::string& replicates(int index) const;
  std::string* mutable_replicates(int index);
  void set_replicates(int index, const std::string& value);
  void set_replicates(int index, std::string&& value);
  void set_replicates(int index, const char* value);
  void set_replicates(int index, const char* value, size_t size);
  std::string* add_replicates();
  void add_replicates(const std::string& value);
  void add_replicates(std::string&& value);
  void add_replicates(const char* value);
  void add_replicates(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& replicates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_replicates();
  private:
  const std::string& _internal_replicates(int index) const;
  std::string* _internal_add_replicates();
  public:

  // .google.protobuf.Timestamp leader_change_ts = 3;
  bool has_leader_change_ts() const;
  private:
  bool _internal_has_leader_change_ts() const;
  public:
  void clear_leader_change_ts();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& leader_change_ts() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_leader_change_ts();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_leader_change_ts();
  void set_allocated_leader_change_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* leader_change_ts);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_leader_change_ts() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_leader_change_ts();
  public:
  void unsafe_arena_set_allocated_leader_change_ts(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* leader_change_ts);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_leader_change_ts();

  // uint64 shard_id = 1;
  void clear_shard_id();
  uint64_t shard_id() const;
  void set_shard_id(uint64_t value);
  private:
  uint64_t _internal_shard_id() const;
  void _internal_set_shard_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.TransferShardLeaderRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> replicates_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* leader_change_ts_;
    uint64_t shard_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class TransferShardLeaderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.TransferShardLeaderResponse) */ {
 public:
  inline TransferShardLeaderResponse() : TransferShardLeaderResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR TransferShardLeaderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferShardLeaderResponse(const TransferShardLeaderResponse& from);
  TransferShardLeaderResponse(TransferShardLeaderResponse&& from) noexcept
    : TransferShardLeaderResponse() {
    *this = ::std::move(from);
  }

  inline TransferShardLeaderResponse& operator=(const TransferShardLeaderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferShardLeaderResponse& operator=(TransferShardLeaderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferShardLeaderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferShardLeaderResponse* internal_default_instance() {
    return reinterpret_cast<const TransferShardLeaderResponse*>(
               &_TransferShardLeaderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(TransferShardLeaderResponse& a, TransferShardLeaderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferShardLeaderResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferShardLeaderResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferShardLeaderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferShardLeaderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const TransferShardLeaderResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const TransferShardLeaderResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.TransferShardLeaderResponse";
  }
  protected:
  explicit TransferShardLeaderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.TransferShardLeaderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class LockShardRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.LockShardRequest) */ {
 public:
  inline LockShardRequest() : LockShardRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR LockShardRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LockShardRequest(const LockShardRequest& from);
  LockShardRequest(LockShardRequest&& from) noexcept
    : LockShardRequest() {
    *this = ::std::move(from);
  }

  inline LockShardRequest& operator=(const LockShardRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LockShardRequest& operator=(LockShardRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LockShardRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LockShardRequest* internal_default_instance() {
    return reinterpret_cast<const LockShardRequest*>(
               &_LockShardRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(LockShardRequest& a, LockShardRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LockShardRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LockShardRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LockShardRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LockShardRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const LockShardRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const LockShardRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.LockShardRequest";
  }
  protected:
  explicit LockShardRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.LockShardRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class LockShardResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.LockShardResponse) */ {
 public:
  inline LockShardResponse() : LockShardResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR LockShardResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LockShardResponse(const LockShardResponse& from);
  LockShardResponse(LockShardResponse&& from) noexcept
    : LockShardResponse() {
    *this = ::std::move(from);
  }

  inline LockShardResponse& operator=(const LockShardResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LockShardResponse& operator=(LockShardResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LockShardResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LockShardResponse* internal_default_instance() {
    return reinterpret_cast<const LockShardResponse*>(
               &_LockShardResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(LockShardResponse& a, LockShardResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LockShardResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LockShardResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LockShardResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LockShardResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const LockShardResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const LockShardResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.LockShardResponse";
  }
  protected:
  explicit LockShardResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.LockShardResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class UnlockShardRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.UnlockShardRequest) */ {
 public:
  inline UnlockShardRequest() : UnlockShardRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UnlockShardRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnlockShardRequest(const UnlockShardRequest& from);
  UnlockShardRequest(UnlockShardRequest&& from) noexcept
    : UnlockShardRequest() {
    *this = ::std::move(from);
  }

  inline UnlockShardRequest& operator=(const UnlockShardRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnlockShardRequest& operator=(UnlockShardRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnlockShardRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnlockShardRequest* internal_default_instance() {
    return reinterpret_cast<const UnlockShardRequest*>(
               &_UnlockShardRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(UnlockShardRequest& a, UnlockShardRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UnlockShardRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnlockShardRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnlockShardRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnlockShardRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UnlockShardRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UnlockShardRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.UnlockShardRequest";
  }
  protected:
  explicit UnlockShardRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.UnlockShardRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class UnlockShardResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.UnlockShardResponse) */ {
 public:
  inline UnlockShardResponse() : UnlockShardResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UnlockShardResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnlockShardResponse(const UnlockShardResponse& from);
  UnlockShardResponse(UnlockShardResponse&& from) noexcept
    : UnlockShardResponse() {
    *this = ::std::move(from);
  }

  inline UnlockShardResponse& operator=(const UnlockShardResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnlockShardResponse& operator=(UnlockShardResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnlockShardResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnlockShardResponse* internal_default_instance() {
    return reinterpret_cast<const UnlockShardResponse*>(
               &_UnlockShardResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(UnlockShardResponse& a, UnlockShardResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UnlockShardResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnlockShardResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnlockShardResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnlockShardResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UnlockShardResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UnlockShardResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.UnlockShardResponse";
  }
  protected:
  explicit UnlockShardResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.UnlockShardResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class ShardReadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.dataserver.ShardReadRequest) */ {
 public:
  inline ShardReadRequest() : ShardReadRequest(nullptr) {}
  ~ShardReadRequest() override;
  explicit PROTOBUF_CONSTEXPR ShardReadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShardReadRequest(const ShardReadRequest& from);
  ShardReadRequest(ShardReadRequest&& from) noexcept
    : ShardReadRequest() {
    *this = ::std::move(from);
  }

  inline ShardReadRequest& operator=(const ShardReadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardReadRequest& operator=(ShardReadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardReadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShardReadRequest* internal_default_instance() {
    return reinterpret_cast<const ShardReadRequest*>(
               &_ShardReadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ShardReadRequest& a, ShardReadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ShardReadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardReadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardReadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShardReadRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShardReadRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShardReadRequest& from) {
    ShardReadRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShardReadRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.ShardReadRequest";
  }
  protected:
  explicit ShardReadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kShardIdFieldNumber = 1,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // uint64 shard_id = 1;
  void clear_shard_id();
  uint64_t shard_id() const;
  void set_shard_id(uint64_t value);
  private:
  uint64_t _internal_shard_id() const;
  void _internal_set_shard_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.ShardReadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    uint64_t shard_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class ShardReadResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.dataserver.ShardReadResponse) */ {
 public:
  inline ShardReadResponse() : ShardReadResponse(nullptr) {}
  ~ShardReadResponse() override;
  explicit PROTOBUF_CONSTEXPR ShardReadResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShardReadResponse(const ShardReadResponse& from);
  ShardReadResponse(ShardReadResponse&& from) noexcept
    : ShardReadResponse() {
    *this = ::std::move(from);
  }

  inline ShardReadResponse& operator=(const ShardReadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardReadResponse& operator=(ShardReadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardReadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShardReadResponse* internal_default_instance() {
    return reinterpret_cast<const ShardReadResponse*>(
               &_ShardReadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ShardReadResponse& a, ShardReadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ShardReadResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardReadResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardReadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShardReadResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShardReadResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShardReadResponse& from) {
    ShardReadResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShardReadResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.ShardReadResponse";
  }
  protected:
  explicit ShardReadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.ShardReadResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class ShardWriteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.dataserver.ShardWriteRequest) */ {
 public:
  inline ShardWriteRequest() : ShardWriteRequest(nullptr) {}
  ~ShardWriteRequest() override;
  explicit PROTOBUF_CONSTEXPR ShardWriteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShardWriteRequest(const ShardWriteRequest& from);
  ShardWriteRequest(ShardWriteRequest&& from) noexcept
    : ShardWriteRequest() {
    *this = ::std::move(from);
  }

  inline ShardWriteRequest& operator=(const ShardWriteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardWriteRequest& operator=(ShardWriteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardWriteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShardWriteRequest* internal_default_instance() {
    return reinterpret_cast<const ShardWriteRequest*>(
               &_ShardWriteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ShardWriteRequest& a, ShardWriteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ShardWriteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardWriteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardWriteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShardWriteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShardWriteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShardWriteRequest& from) {
    ShardWriteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShardWriteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.ShardWriteRequest";
  }
  protected:
  explicit ShardWriteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kValueFieldNumber = 3,
    kShardIdFieldNumber = 1,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bytes value = 3;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // uint64 shard_id = 1;
  void clear_shard_id();
  uint64_t shard_id() const;
  void set_shard_id(uint64_t value);
  private:
  uint64_t _internal_shard_id() const;
  void _internal_set_shard_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.ShardWriteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    uint64_t shard_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class ShardWriteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.dataserver.ShardWriteResponse) */ {
 public:
  inline ShardWriteResponse() : ShardWriteResponse(nullptr) {}
  ~ShardWriteResponse() override;
  explicit PROTOBUF_CONSTEXPR ShardWriteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShardWriteResponse(const ShardWriteResponse& from);
  ShardWriteResponse(ShardWriteResponse&& from) noexcept
    : ShardWriteResponse() {
    *this = ::std::move(from);
  }

  inline ShardWriteResponse& operator=(const ShardWriteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardWriteResponse& operator=(ShardWriteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardWriteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShardWriteResponse* internal_default_instance() {
    return reinterpret_cast<const ShardWriteResponse*>(
               &_ShardWriteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ShardWriteResponse& a, ShardWriteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ShardWriteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardWriteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardWriteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShardWriteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShardWriteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShardWriteResponse& from) {
    ShardWriteResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShardWriteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.ShardWriteResponse";
  }
  protected:
  explicit ShardWriteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNotLeaderFieldNumber = 1,
  };
  // bool not_leader = 1;
  void clear_not_leader();
  bool not_leader() const;
  void set_not_leader(bool value);
  private:
  bool _internal_not_leader() const;
  void _internal_set_not_leader(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.ShardWriteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool not_leader_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class ShardAppendLogRequest_Entry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.dataserver.ShardAppendLogRequest.Entry) */ {
 public:
  inline ShardAppendLogRequest_Entry() : ShardAppendLogRequest_Entry(nullptr) {}
  ~ShardAppendLogRequest_Entry() override;
  explicit PROTOBUF_CONSTEXPR ShardAppendLogRequest_Entry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShardAppendLogRequest_Entry(const ShardAppendLogRequest_Entry& from);
  ShardAppendLogRequest_Entry(ShardAppendLogRequest_Entry&& from) noexcept
    : ShardAppendLogRequest_Entry() {
    *this = ::std::move(from);
  }

  inline ShardAppendLogRequest_Entry& operator=(const ShardAppendLogRequest_Entry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardAppendLogRequest_Entry& operator=(ShardAppendLogRequest_Entry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardAppendLogRequest_Entry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShardAppendLogRequest_Entry* internal_default_instance() {
    return reinterpret_cast<const ShardAppendLogRequest_Entry*>(
               &_ShardAppendLogRequest_Entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ShardAppendLogRequest_Entry& a, ShardAppendLogRequest_Entry& b) {
    a.Swap(&b);
  }
  inline void Swap(ShardAppendLogRequest_Entry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardAppendLogRequest_Entry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardAppendLogRequest_Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShardAppendLogRequest_Entry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShardAppendLogRequest_Entry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShardAppendLogRequest_Entry& from) {
    ShardAppendLogRequest_Entry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShardAppendLogRequest_Entry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.ShardAppendLogRequest.Entry";
  }
  protected:
  explicit ShardAppendLogRequest_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpFieldNumber = 1,
    kKeyFieldNumber = 3,
    kValueFieldNumber = 4,
    kIndexFieldNumber = 2,
  };
  // string op = 1;
  void clear_op();
  const std::string& op() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_op(ArgT0&& arg0, ArgT... args);
  std::string* mutable_op();
  PROTOBUF_NODISCARD std::string* release_op();
  void set_allocated_op(std::string* op);
  private:
  const std::string& _internal_op() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_op(const std::string& value);
  std::string* _internal_mutable_op();
  public:

  // bytes key = 3;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bytes value = 4;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // uint64 index = 2;
  void clear_index();
  uint64_t index() const;
  void set_index(uint64_t value);
  private:
  uint64_t _internal_index() const;
  void _internal_set_index(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.ShardAppendLogRequest.Entry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr op_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    uint64_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class ShardAppendLogRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.dataserver.ShardAppendLogRequest) */ {
 public:
  inline ShardAppendLogRequest() : ShardAppendLogRequest(nullptr) {}
  ~ShardAppendLogRequest() override;
  explicit PROTOBUF_CONSTEXPR ShardAppendLogRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShardAppendLogRequest(const ShardAppendLogRequest& from);
  ShardAppendLogRequest(ShardAppendLogRequest&& from) noexcept
    : ShardAppendLogRequest() {
    *this = ::std::move(from);
  }

  inline ShardAppendLogRequest& operator=(const ShardAppendLogRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardAppendLogRequest& operator=(ShardAppendLogRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardAppendLogRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShardAppendLogRequest* internal_default_instance() {
    return reinterpret_cast<const ShardAppendLogRequest*>(
               &_ShardAppendLogRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ShardAppendLogRequest& a, ShardAppendLogRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ShardAppendLogRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardAppendLogRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardAppendLogRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShardAppendLogRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShardAppendLogRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShardAppendLogRequest& from) {
    ShardAppendLogRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShardAppendLogRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.ShardAppendLogRequest";
  }
  protected:
  explicit ShardAppendLogRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ShardAppendLogRequest_Entry Entry;

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 3,
    kLeaderChangeTsFieldNumber = 2,
    kShardIdFieldNumber = 1,
  };
  // repeated .bedrock.dataserver.ShardAppendLogRequest.Entry entries = 3;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::bedrock::dataserver::ShardAppendLogRequest_Entry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bedrock::dataserver::ShardAppendLogRequest_Entry >*
      mutable_entries();
  private:
  const ::bedrock::dataserver::ShardAppendLogRequest_Entry& _internal_entries(int index) const;
  ::bedrock::dataserver::ShardAppendLogRequest_Entry* _internal_add_entries();
  public:
  const ::bedrock::dataserver::ShardAppendLogRequest_Entry& entries(int index) const;
  ::bedrock::dataserver::ShardAppendLogRequest_Entry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bedrock::dataserver::ShardAppendLogRequest_Entry >&
      entries() const;

  // .google.protobuf.Timestamp leader_change_ts = 2;
  bool has_leader_change_ts() const;
  private:
  bool _internal_has_leader_change_ts() const;
  public:
  void clear_leader_change_ts();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& leader_change_ts() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_leader_change_ts();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_leader_change_ts();
  void set_allocated_leader_change_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* leader_change_ts);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_leader_change_ts() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_leader_change_ts();
  public:
  void unsafe_arena_set_allocated_leader_change_ts(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* leader_change_ts);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_leader_change_ts();

  // uint64 shard_id = 1;
  void clear_shard_id();
  uint64_t shard_id() const;
  void set_shard_id(uint64_t value);
  private:
  uint64_t _internal_shard_id() const;
  void _internal_set_shard_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.ShardAppendLogRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bedrock::dataserver::ShardAppendLogRequest_Entry > entries_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* leader_change_ts_;
    uint64_t shard_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class ShardAppendLogResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.dataserver.ShardAppendLogResponse) */ {
 public:
  inline ShardAppendLogResponse() : ShardAppendLogResponse(nullptr) {}
  ~ShardAppendLogResponse() override;
  explicit PROTOBUF_CONSTEXPR ShardAppendLogResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShardAppendLogResponse(const ShardAppendLogResponse& from);
  ShardAppendLogResponse(ShardAppendLogResponse&& from) noexcept
    : ShardAppendLogResponse() {
    *this = ::std::move(from);
  }

  inline ShardAppendLogResponse& operator=(const ShardAppendLogResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardAppendLogResponse& operator=(ShardAppendLogResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardAppendLogResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShardAppendLogResponse* internal_default_instance() {
    return reinterpret_cast<const ShardAppendLogResponse*>(
               &_ShardAppendLogResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ShardAppendLogResponse& a, ShardAppendLogResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ShardAppendLogResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardAppendLogResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardAppendLogResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShardAppendLogResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShardAppendLogResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShardAppendLogResponse& from) {
    ShardAppendLogResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShardAppendLogResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.ShardAppendLogResponse";
  }
  protected:
  explicit ShardAppendLogResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLastAppliedIndexFieldNumber = 2,
    kIsOldLeaderFieldNumber = 1,
  };
  // uint64 last_applied_index = 2;
  void clear_last_applied_index();
  uint64_t last_applied_index() const;
  void set_last_applied_index(uint64_t value);
  private:
  uint64_t _internal_last_applied_index() const;
  void _internal_set_last_applied_index(uint64_t value);
  public:

  // bool is_old_leader = 1;
  void clear_is_old_leader();
  bool is_old_leader() const;
  void set_is_old_leader(bool value);
  private:
  bool _internal_is_old_leader() const;
  void _internal_set_is_old_leader(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.ShardAppendLogResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t last_applied_index_;
    bool is_old_leader_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class ShardInstallSnapshotRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bedrock.dataserver.ShardInstallSnapshotRequest) */ {
 public:
  inline ShardInstallSnapshotRequest() : ShardInstallSnapshotRequest(nullptr) {}
  ~ShardInstallSnapshotRequest() override;
  explicit PROTOBUF_CONSTEXPR ShardInstallSnapshotRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShardInstallSnapshotRequest(const ShardInstallSnapshotRequest& from);
  ShardInstallSnapshotRequest(ShardInstallSnapshotRequest&& from) noexcept
    : ShardInstallSnapshotRequest() {
    *this = ::std::move(from);
  }

  inline ShardInstallSnapshotRequest& operator=(const ShardInstallSnapshotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardInstallSnapshotRequest& operator=(ShardInstallSnapshotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardInstallSnapshotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShardInstallSnapshotRequest* internal_default_instance() {
    return reinterpret_cast<const ShardInstallSnapshotRequest*>(
               &_ShardInstallSnapshotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ShardInstallSnapshotRequest& a, ShardInstallSnapshotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ShardInstallSnapshotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardInstallSnapshotRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardInstallSnapshotRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShardInstallSnapshotRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShardInstallSnapshotRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShardInstallSnapshotRequest& from) {
    ShardInstallSnapshotRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShardInstallSnapshotRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.ShardInstallSnapshotRequest";
  }
  protected:
  explicit ShardInstallSnapshotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataPieceFieldNumber = 2,
    kShardIdFieldNumber = 1,
    kLastWalIndexFieldNumber = 3,
  };
  // bytes data_piece = 2;
  void clear_data_piece();
  const std::string& data_piece() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_piece(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_piece();
  PROTOBUF_NODISCARD std::string* release_data_piece();
  void set_allocated_data_piece(std::string* data_piece);
  private:
  const std::string& _internal_data_piece() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_piece(const std::string& value);
  std::string* _internal_mutable_data_piece();
  public:

  // uint64 shard_id = 1;
  void clear_shard_id();
  uint64_t shard_id() const;
  void set_shard_id(uint64_t value);
  private:
  uint64_t _internal_shard_id() const;
  void _internal_set_shard_id(uint64_t value);
  public:

  // uint64 last_wal_index = 3;
  void clear_last_wal_index();
  uint64_t last_wal_index() const;
  void set_last_wal_index(uint64_t value);
  private:
  uint64_t _internal_last_wal_index() const;
  void _internal_set_last_wal_index(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.ShardInstallSnapshotRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_piece_;
    uint64_t shard_id_;
    uint64_t last_wal_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class ShardInstallSnapshotResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.ShardInstallSnapshotResponse) */ {
 public:
  inline ShardInstallSnapshotResponse() : ShardInstallSnapshotResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ShardInstallSnapshotResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShardInstallSnapshotResponse(const ShardInstallSnapshotResponse& from);
  ShardInstallSnapshotResponse(ShardInstallSnapshotResponse&& from) noexcept
    : ShardInstallSnapshotResponse() {
    *this = ::std::move(from);
  }

  inline ShardInstallSnapshotResponse& operator=(const ShardInstallSnapshotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardInstallSnapshotResponse& operator=(ShardInstallSnapshotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardInstallSnapshotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShardInstallSnapshotResponse* internal_default_instance() {
    return reinterpret_cast<const ShardInstallSnapshotResponse*>(
               &_ShardInstallSnapshotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ShardInstallSnapshotResponse& a, ShardInstallSnapshotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ShardInstallSnapshotResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardInstallSnapshotResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardInstallSnapshotResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShardInstallSnapshotResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ShardInstallSnapshotResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ShardInstallSnapshotResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.ShardInstallSnapshotResponse";
  }
  protected:
  explicit ShardInstallSnapshotResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.ShardInstallSnapshotResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class ShardWriteReplicaRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.ShardWriteReplicaRequest) */ {
 public:
  inline ShardWriteReplicaRequest() : ShardWriteReplicaRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ShardWriteReplicaRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShardWriteReplicaRequest(const ShardWriteReplicaRequest& from);
  ShardWriteReplicaRequest(ShardWriteReplicaRequest&& from) noexcept
    : ShardWriteReplicaRequest() {
    *this = ::std::move(from);
  }

  inline ShardWriteReplicaRequest& operator=(const ShardWriteReplicaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardWriteReplicaRequest& operator=(ShardWriteReplicaRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardWriteReplicaRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShardWriteReplicaRequest* internal_default_instance() {
    return reinterpret_cast<const ShardWriteReplicaRequest*>(
               &_ShardWriteReplicaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ShardWriteReplicaRequest& a, ShardWriteReplicaRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ShardWriteReplicaRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardWriteReplicaRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardWriteReplicaRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShardWriteReplicaRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ShardWriteReplicaRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ShardWriteReplicaRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.ShardWriteReplicaRequest";
  }
  protected:
  explicit ShardWriteReplicaRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.ShardWriteReplicaRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class ShardWriteReplicaResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.ShardWriteReplicaResponse) */ {
 public:
  inline ShardWriteReplicaResponse() : ShardWriteReplicaResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ShardWriteReplicaResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShardWriteReplicaResponse(const ShardWriteReplicaResponse& from);
  ShardWriteReplicaResponse(ShardWriteReplicaResponse&& from) noexcept
    : ShardWriteReplicaResponse() {
    *this = ::std::move(from);
  }

  inline ShardWriteReplicaResponse& operator=(const ShardWriteReplicaResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardWriteReplicaResponse& operator=(ShardWriteReplicaResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardWriteReplicaResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShardWriteReplicaResponse* internal_default_instance() {
    return reinterpret_cast<const ShardWriteReplicaResponse*>(
               &_ShardWriteReplicaResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ShardWriteReplicaResponse& a, ShardWriteReplicaResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ShardWriteReplicaResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardWriteReplicaResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardWriteReplicaResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShardWriteReplicaResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ShardWriteReplicaResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ShardWriteReplicaResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.ShardWriteReplicaResponse";
  }
  protected:
  explicit ShardWriteReplicaResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.ShardWriteReplicaResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class ShardRepairRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.ShardRepairRequest) */ {
 public:
  inline ShardRepairRequest() : ShardRepairRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ShardRepairRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShardRepairRequest(const ShardRepairRequest& from);
  ShardRepairRequest(ShardRepairRequest&& from) noexcept
    : ShardRepairRequest() {
    *this = ::std::move(from);
  }

  inline ShardRepairRequest& operator=(const ShardRepairRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardRepairRequest& operator=(ShardRepairRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardRepairRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShardRepairRequest* internal_default_instance() {
    return reinterpret_cast<const ShardRepairRequest*>(
               &_ShardRepairRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ShardRepairRequest& a, ShardRepairRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ShardRepairRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardRepairRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardRepairRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShardRepairRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ShardRepairRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ShardRepairRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.ShardRepairRequest";
  }
  protected:
  explicit ShardRepairRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.ShardRepairRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class ShardRepairResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.ShardRepairResponse) */ {
 public:
  inline ShardRepairResponse() : ShardRepairResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ShardRepairResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShardRepairResponse(const ShardRepairResponse& from);
  ShardRepairResponse(ShardRepairResponse&& from) noexcept
    : ShardRepairResponse() {
    *this = ::std::move(from);
  }

  inline ShardRepairResponse& operator=(const ShardRepairResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardRepairResponse& operator=(ShardRepairResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardRepairResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShardRepairResponse* internal_default_instance() {
    return reinterpret_cast<const ShardRepairResponse*>(
               &_ShardRepairResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ShardRepairResponse& a, ShardRepairResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ShardRepairResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardRepairResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardRepairResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShardRepairResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ShardRepairResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ShardRepairResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.ShardRepairResponse";
  }
  protected:
  explicit ShardRepairResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.ShardRepairResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class DataServerJoinRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.DataServerJoinRequest) */ {
 public:
  inline DataServerJoinRequest() : DataServerJoinRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DataServerJoinRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataServerJoinRequest(const DataServerJoinRequest& from);
  DataServerJoinRequest(DataServerJoinRequest&& from) noexcept
    : DataServerJoinRequest() {
    *this = ::std::move(from);
  }

  inline DataServerJoinRequest& operator=(const DataServerJoinRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataServerJoinRequest& operator=(DataServerJoinRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataServerJoinRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataServerJoinRequest* internal_default_instance() {
    return reinterpret_cast<const DataServerJoinRequest*>(
               &_DataServerJoinRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(DataServerJoinRequest& a, DataServerJoinRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DataServerJoinRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataServerJoinRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataServerJoinRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataServerJoinRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DataServerJoinRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DataServerJoinRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.DataServerJoinRequest";
  }
  protected:
  explicit DataServerJoinRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.DataServerJoinRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class DataServerJoinResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.DataServerJoinResponse) */ {
 public:
  inline DataServerJoinResponse() : DataServerJoinResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DataServerJoinResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataServerJoinResponse(const DataServerJoinResponse& from);
  DataServerJoinResponse(DataServerJoinResponse&& from) noexcept
    : DataServerJoinResponse() {
    *this = ::std::move(from);
  }

  inline DataServerJoinResponse& operator=(const DataServerJoinResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataServerJoinResponse& operator=(DataServerJoinResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataServerJoinResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataServerJoinResponse* internal_default_instance() {
    return reinterpret_cast<const DataServerJoinResponse*>(
               &_DataServerJoinResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(DataServerJoinResponse& a, DataServerJoinResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DataServerJoinResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataServerJoinResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataServerJoinResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataServerJoinResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DataServerJoinResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DataServerJoinResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.DataServerJoinResponse";
  }
  protected:
  explicit DataServerJoinResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.DataServerJoinResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class DataServerLeaveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.DataServerLeaveRequest) */ {
 public:
  inline DataServerLeaveRequest() : DataServerLeaveRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DataServerLeaveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataServerLeaveRequest(const DataServerLeaveRequest& from);
  DataServerLeaveRequest(DataServerLeaveRequest&& from) noexcept
    : DataServerLeaveRequest() {
    *this = ::std::move(from);
  }

  inline DataServerLeaveRequest& operator=(const DataServerLeaveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataServerLeaveRequest& operator=(DataServerLeaveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataServerLeaveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataServerLeaveRequest* internal_default_instance() {
    return reinterpret_cast<const DataServerLeaveRequest*>(
               &_DataServerLeaveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(DataServerLeaveRequest& a, DataServerLeaveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DataServerLeaveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataServerLeaveRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataServerLeaveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataServerLeaveRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DataServerLeaveRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DataServerLeaveRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.DataServerLeaveRequest";
  }
  protected:
  explicit DataServerLeaveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.DataServerLeaveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// -------------------------------------------------------------------

class DataServerLeaveResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bedrock.dataserver.DataServerLeaveResponse) */ {
 public:
  inline DataServerLeaveResponse() : DataServerLeaveResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DataServerLeaveResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataServerLeaveResponse(const DataServerLeaveResponse& from);
  DataServerLeaveResponse(DataServerLeaveResponse&& from) noexcept
    : DataServerLeaveResponse() {
    *this = ::std::move(from);
  }

  inline DataServerLeaveResponse& operator=(const DataServerLeaveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataServerLeaveResponse& operator=(DataServerLeaveResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataServerLeaveResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataServerLeaveResponse* internal_default_instance() {
    return reinterpret_cast<const DataServerLeaveResponse*>(
               &_DataServerLeaveResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(DataServerLeaveResponse& a, DataServerLeaveResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DataServerLeaveResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataServerLeaveResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataServerLeaveResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataServerLeaveResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DataServerLeaveResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DataServerLeaveResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bedrock.dataserver.DataServerLeaveResponse";
  }
  protected:
  explicit DataServerLeaveResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bedrock.dataserver.DataServerLeaveResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dataserver_2eproto;
};
// ===================================================================

class DataService_Stub;

class DataService : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline DataService() {};
 public:
  virtual ~DataService();

  typedef DataService_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void CreateShard(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::dataserver::CreateShardRequest* request,
                       ::bedrock::dataserver::CreateShardResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void DeleteShard(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::dataserver::DeleteShardRequest* request,
                       ::PROTOBUF_NAMESPACE_ID::Empty* response,
                       ::google::protobuf::Closure* done);
  virtual void TransferShardLeader(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::dataserver::TransferShardLeaderRequest* request,
                       ::bedrock::dataserver::TransferShardLeaderResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void ShardRead(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::dataserver::ShardReadRequest* request,
                       ::bedrock::dataserver::ShardReadResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void ShardWrite(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::dataserver::ShardWriteRequest* request,
                       ::bedrock::dataserver::ShardWriteResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void ShardAppendLog(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::dataserver::ShardAppendLogRequest* request,
                       ::bedrock::dataserver::ShardAppendLogResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void ShardInstallSnapshot(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::dataserver::ShardInstallSnapshotRequest* request,
                       ::bedrock::dataserver::ShardInstallSnapshotResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(DataService);
};

class DataService_Stub : public DataService {
 public:
  DataService_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  DataService_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~DataService_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements DataService ------------------------------------------

  void CreateShard(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::dataserver::CreateShardRequest* request,
                       ::bedrock::dataserver::CreateShardResponse* response,
                       ::google::protobuf::Closure* done);
  void DeleteShard(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::dataserver::DeleteShardRequest* request,
                       ::PROTOBUF_NAMESPACE_ID::Empty* response,
                       ::google::protobuf::Closure* done);
  void TransferShardLeader(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::dataserver::TransferShardLeaderRequest* request,
                       ::bedrock::dataserver::TransferShardLeaderResponse* response,
                       ::google::protobuf::Closure* done);
  void ShardRead(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::dataserver::ShardReadRequest* request,
                       ::bedrock::dataserver::ShardReadResponse* response,
                       ::google::protobuf::Closure* done);
  void ShardWrite(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::dataserver::ShardWriteRequest* request,
                       ::bedrock::dataserver::ShardWriteResponse* response,
                       ::google::protobuf::Closure* done);
  void ShardAppendLog(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::dataserver::ShardAppendLogRequest* request,
                       ::bedrock::dataserver::ShardAppendLogResponse* response,
                       ::google::protobuf::Closure* done);
  void ShardInstallSnapshot(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::bedrock::dataserver::ShardInstallSnapshotRequest* request,
                       ::bedrock::dataserver::ShardInstallSnapshotResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(DataService_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ShardMeta

// uint64 shard_id = 1;
inline void ShardMeta::clear_shard_id() {
  _impl_.shard_id_ = uint64_t{0u};
}
inline uint64_t ShardMeta::_internal_shard_id() const {
  return _impl_.shard_id_;
}
inline uint64_t ShardMeta::shard_id() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardMeta.shard_id)
  return _internal_shard_id();
}
inline void ShardMeta::_internal_set_shard_id(uint64_t value) {
  
  _impl_.shard_id_ = value;
}
inline void ShardMeta::set_shard_id(uint64_t value) {
  _internal_set_shard_id(value);
  // @@protoc_insertion_point(field_set:bedrock.dataserver.ShardMeta.shard_id)
}

// uint64 storage_id = 2;
inline void ShardMeta::clear_storage_id() {
  _impl_.storage_id_ = uint64_t{0u};
}
inline uint64_t ShardMeta::_internal_storage_id() const {
  return _impl_.storage_id_;
}
inline uint64_t ShardMeta::storage_id() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardMeta.storage_id)
  return _internal_storage_id();
}
inline void ShardMeta::_internal_set_storage_id(uint64_t value) {
  
  _impl_.storage_id_ = value;
}
inline void ShardMeta::set_storage_id(uint64_t value) {
  _internal_set_storage_id(value);
  // @@protoc_insertion_point(field_set:bedrock.dataserver.ShardMeta.storage_id)
}

// .google.protobuf.Timestamp create_ts = 3;
inline bool ShardMeta::_internal_has_create_ts() const {
  return this != internal_default_instance() && _impl_.create_ts_ != nullptr;
}
inline bool ShardMeta::has_create_ts() const {
  return _internal_has_create_ts();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ShardMeta::_internal_create_ts() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.create_ts_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ShardMeta::create_ts() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardMeta.create_ts)
  return _internal_create_ts();
}
inline void ShardMeta::unsafe_arena_set_allocated_create_ts(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_ts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_ts_);
  }
  _impl_.create_ts_ = create_ts;
  if (create_ts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bedrock.dataserver.ShardMeta.create_ts)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ShardMeta::release_create_ts() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_ts_;
  _impl_.create_ts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ShardMeta::unsafe_arena_release_create_ts() {
  // @@protoc_insertion_point(field_release:bedrock.dataserver.ShardMeta.create_ts)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_ts_;
  _impl_.create_ts_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ShardMeta::_internal_mutable_create_ts() {
  
  if (_impl_.create_ts_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.create_ts_ = p;
  }
  return _impl_.create_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ShardMeta::mutable_create_ts() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_create_ts();
  // @@protoc_insertion_point(field_mutable:bedrock.dataserver.ShardMeta.create_ts)
  return _msg;
}
inline void ShardMeta::set_allocated_create_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* create_ts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_ts_);
  }
  if (create_ts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_ts));
    if (message_arena != submessage_arena) {
      create_ts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_ts, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.create_ts_ = create_ts;
  // @@protoc_insertion_point(field_set_allocated:bedrock.dataserver.ShardMeta.create_ts)
}

// repeated string replicates = 4;
inline int ShardMeta::_internal_replicates_size() const {
  return _impl_.replicates_.size();
}
inline int ShardMeta::replicates_size() const {
  return _internal_replicates_size();
}
inline void ShardMeta::clear_replicates() {
  _impl_.replicates_.Clear();
}
inline std::string* ShardMeta::add_replicates() {
  std::string* _s = _internal_add_replicates();
  // @@protoc_insertion_point(field_add_mutable:bedrock.dataserver.ShardMeta.replicates)
  return _s;
}
inline const std::string& ShardMeta::_internal_replicates(int index) const {
  return _impl_.replicates_.Get(index);
}
inline const std::string& ShardMeta::replicates(int index) const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardMeta.replicates)
  return _internal_replicates(index);
}
inline std::string* ShardMeta::mutable_replicates(int index) {
  // @@protoc_insertion_point(field_mutable:bedrock.dataserver.ShardMeta.replicates)
  return _impl_.replicates_.Mutable(index);
}
inline void ShardMeta::set_replicates(int index, const std::string& value) {
  _impl_.replicates_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bedrock.dataserver.ShardMeta.replicates)
}
inline void ShardMeta::set_replicates(int index, std::string&& value) {
  _impl_.replicates_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bedrock.dataserver.ShardMeta.replicates)
}
inline void ShardMeta::set_replicates(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.replicates_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bedrock.dataserver.ShardMeta.replicates)
}
inline void ShardMeta::set_replicates(int index, const char* value, size_t size) {
  _impl_.replicates_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bedrock.dataserver.ShardMeta.replicates)
}
inline std::string* ShardMeta::_internal_add_replicates() {
  return _impl_.replicates_.Add();
}
inline void ShardMeta::add_replicates(const std::string& value) {
  _impl_.replicates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bedrock.dataserver.ShardMeta.replicates)
}
inline void ShardMeta::add_replicates(std::string&& value) {
  _impl_.replicates_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bedrock.dataserver.ShardMeta.replicates)
}
inline void ShardMeta::add_replicates(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.replicates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bedrock.dataserver.ShardMeta.replicates)
}
inline void ShardMeta::add_replicates(const char* value, size_t size) {
  _impl_.replicates_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bedrock.dataserver.ShardMeta.replicates)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ShardMeta::replicates() const {
  // @@protoc_insertion_point(field_list:bedrock.dataserver.ShardMeta.replicates)
  return _impl_.replicates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ShardMeta::mutable_replicates() {
  // @@protoc_insertion_point(field_mutable_list:bedrock.dataserver.ShardMeta.replicates)
  return &_impl_.replicates_;
}

// .google.protobuf.Timestamp replicates_update_ts = 5;
inline bool ShardMeta::_internal_has_replicates_update_ts() const {
  return this != internal_default_instance() && _impl_.replicates_update_ts_ != nullptr;
}
inline bool ShardMeta::has_replicates_update_ts() const {
  return _internal_has_replicates_update_ts();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ShardMeta::_internal_replicates_update_ts() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.replicates_update_ts_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ShardMeta::replicates_update_ts() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardMeta.replicates_update_ts)
  return _internal_replicates_update_ts();
}
inline void ShardMeta::unsafe_arena_set_allocated_replicates_update_ts(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* replicates_update_ts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.replicates_update_ts_);
  }
  _impl_.replicates_update_ts_ = replicates_update_ts;
  if (replicates_update_ts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bedrock.dataserver.ShardMeta.replicates_update_ts)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ShardMeta::release_replicates_update_ts() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.replicates_update_ts_;
  _impl_.replicates_update_ts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ShardMeta::unsafe_arena_release_replicates_update_ts() {
  // @@protoc_insertion_point(field_release:bedrock.dataserver.ShardMeta.replicates_update_ts)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.replicates_update_ts_;
  _impl_.replicates_update_ts_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ShardMeta::_internal_mutable_replicates_update_ts() {
  
  if (_impl_.replicates_update_ts_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.replicates_update_ts_ = p;
  }
  return _impl_.replicates_update_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ShardMeta::mutable_replicates_update_ts() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_replicates_update_ts();
  // @@protoc_insertion_point(field_mutable:bedrock.dataserver.ShardMeta.replicates_update_ts)
  return _msg;
}
inline void ShardMeta::set_allocated_replicates_update_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* replicates_update_ts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.replicates_update_ts_);
  }
  if (replicates_update_ts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(replicates_update_ts));
    if (message_arena != submessage_arena) {
      replicates_update_ts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, replicates_update_ts, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.replicates_update_ts_ = replicates_update_ts;
  // @@protoc_insertion_point(field_set_allocated:bedrock.dataserver.ShardMeta.replicates_update_ts)
}

// bool is_leader = 6;
inline void ShardMeta::clear_is_leader() {
  _impl_.is_leader_ = false;
}
inline bool ShardMeta::_internal_is_leader() const {
  return _impl_.is_leader_;
}
inline bool ShardMeta::is_leader() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardMeta.is_leader)
  return _internal_is_leader();
}
inline void ShardMeta::_internal_set_is_leader(bool value) {
  
  _impl_.is_leader_ = value;
}
inline void ShardMeta::set_is_leader(bool value) {
  _internal_set_is_leader(value);
  // @@protoc_insertion_point(field_set:bedrock.dataserver.ShardMeta.is_leader)
}

// string leader = 7;
inline void ShardMeta::clear_leader() {
  _impl_.leader_.ClearToEmpty();
}
inline const std::string& ShardMeta::leader() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardMeta.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShardMeta::set_leader(ArgT0&& arg0, ArgT... args) {
 
 _impl_.leader_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bedrock.dataserver.ShardMeta.leader)
}
inline std::string* ShardMeta::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:bedrock.dataserver.ShardMeta.leader)
  return _s;
}
inline const std::string& ShardMeta::_internal_leader() const {
  return _impl_.leader_.Get();
}
inline void ShardMeta::_internal_set_leader(const std::string& value) {
  
  _impl_.leader_.Set(value, GetArenaForAllocation());
}
inline std::string* ShardMeta::_internal_mutable_leader() {
  
  return _impl_.leader_.Mutable(GetArenaForAllocation());
}
inline std::string* ShardMeta::release_leader() {
  // @@protoc_insertion_point(field_release:bedrock.dataserver.ShardMeta.leader)
  return _impl_.leader_.Release();
}
inline void ShardMeta::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    
  } else {
    
  }
  _impl_.leader_.SetAllocated(leader, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_.IsDefault()) {
    _impl_.leader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bedrock.dataserver.ShardMeta.leader)
}

// .google.protobuf.Timestamp leader_change_ts = 8;
inline bool ShardMeta::_internal_has_leader_change_ts() const {
  return this != internal_default_instance() && _impl_.leader_change_ts_ != nullptr;
}
inline bool ShardMeta::has_leader_change_ts() const {
  return _internal_has_leader_change_ts();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ShardMeta::_internal_leader_change_ts() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.leader_change_ts_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ShardMeta::leader_change_ts() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardMeta.leader_change_ts)
  return _internal_leader_change_ts();
}
inline void ShardMeta::unsafe_arena_set_allocated_leader_change_ts(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* leader_change_ts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.leader_change_ts_);
  }
  _impl_.leader_change_ts_ = leader_change_ts;
  if (leader_change_ts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bedrock.dataserver.ShardMeta.leader_change_ts)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ShardMeta::release_leader_change_ts() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.leader_change_ts_;
  _impl_.leader_change_ts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ShardMeta::unsafe_arena_release_leader_change_ts() {
  // @@protoc_insertion_point(field_release:bedrock.dataserver.ShardMeta.leader_change_ts)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.leader_change_ts_;
  _impl_.leader_change_ts_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ShardMeta::_internal_mutable_leader_change_ts() {
  
  if (_impl_.leader_change_ts_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.leader_change_ts_ = p;
  }
  return _impl_.leader_change_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ShardMeta::mutable_leader_change_ts() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_leader_change_ts();
  // @@protoc_insertion_point(field_mutable:bedrock.dataserver.ShardMeta.leader_change_ts)
  return _msg;
}
inline void ShardMeta::set_allocated_leader_change_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* leader_change_ts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.leader_change_ts_);
  }
  if (leader_change_ts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(leader_change_ts));
    if (message_arena != submessage_arena) {
      leader_change_ts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leader_change_ts, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.leader_change_ts_ = leader_change_ts;
  // @@protoc_insertion_point(field_set_allocated:bedrock.dataserver.ShardMeta.leader_change_ts)
}

// uint64 last_wal_index = 9;
inline void ShardMeta::clear_last_wal_index() {
  _impl_.last_wal_index_ = uint64_t{0u};
}
inline uint64_t ShardMeta::_internal_last_wal_index() const {
  return _impl_.last_wal_index_;
}
inline uint64_t ShardMeta::last_wal_index() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardMeta.last_wal_index)
  return _internal_last_wal_index();
}
inline void ShardMeta::_internal_set_last_wal_index(uint64_t value) {
  
  _impl_.last_wal_index_ = value;
}
inline void ShardMeta::set_last_wal_index(uint64_t value) {
  _internal_set_last_wal_index(value);
  // @@protoc_insertion_point(field_set:bedrock.dataserver.ShardMeta.last_wal_index)
}

// -------------------------------------------------------------------

// SplitShardRequest

// -------------------------------------------------------------------

// SplitShardResponse

// -------------------------------------------------------------------

// MergeShardRequest

// -------------------------------------------------------------------

// MergeShardResponse

// -------------------------------------------------------------------

// CreateShardRequest

// uint64 shard_id = 1;
inline void CreateShardRequest::clear_shard_id() {
  _impl_.shard_id_ = uint64_t{0u};
}
inline uint64_t CreateShardRequest::_internal_shard_id() const {
  return _impl_.shard_id_;
}
inline uint64_t CreateShardRequest::shard_id() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.CreateShardRequest.shard_id)
  return _internal_shard_id();
}
inline void CreateShardRequest::_internal_set_shard_id(uint64_t value) {
  
  _impl_.shard_id_ = value;
}
inline void CreateShardRequest::set_shard_id(uint64_t value) {
  _internal_set_shard_id(value);
  // @@protoc_insertion_point(field_set:bedrock.dataserver.CreateShardRequest.shard_id)
}

// uint64 storage_id = 2;
inline void CreateShardRequest::clear_storage_id() {
  _impl_.storage_id_ = uint64_t{0u};
}
inline uint64_t CreateShardRequest::_internal_storage_id() const {
  return _impl_.storage_id_;
}
inline uint64_t CreateShardRequest::storage_id() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.CreateShardRequest.storage_id)
  return _internal_storage_id();
}
inline void CreateShardRequest::_internal_set_storage_id(uint64_t value) {
  
  _impl_.storage_id_ = value;
}
inline void CreateShardRequest::set_storage_id(uint64_t value) {
  _internal_set_storage_id(value);
  // @@protoc_insertion_point(field_set:bedrock.dataserver.CreateShardRequest.storage_id)
}

// .google.protobuf.Timestamp create_ts = 3;
inline bool CreateShardRequest::_internal_has_create_ts() const {
  return this != internal_default_instance() && _impl_.create_ts_ != nullptr;
}
inline bool CreateShardRequest::has_create_ts() const {
  return _internal_has_create_ts();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CreateShardRequest::_internal_create_ts() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.create_ts_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CreateShardRequest::create_ts() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.CreateShardRequest.create_ts)
  return _internal_create_ts();
}
inline void CreateShardRequest::unsafe_arena_set_allocated_create_ts(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_ts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_ts_);
  }
  _impl_.create_ts_ = create_ts;
  if (create_ts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bedrock.dataserver.CreateShardRequest.create_ts)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateShardRequest::release_create_ts() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_ts_;
  _impl_.create_ts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateShardRequest::unsafe_arena_release_create_ts() {
  // @@protoc_insertion_point(field_release:bedrock.dataserver.CreateShardRequest.create_ts)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_ts_;
  _impl_.create_ts_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateShardRequest::_internal_mutable_create_ts() {
  
  if (_impl_.create_ts_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.create_ts_ = p;
  }
  return _impl_.create_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateShardRequest::mutable_create_ts() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_create_ts();
  // @@protoc_insertion_point(field_mutable:bedrock.dataserver.CreateShardRequest.create_ts)
  return _msg;
}
inline void CreateShardRequest::set_allocated_create_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* create_ts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_ts_);
  }
  if (create_ts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_ts));
    if (message_arena != submessage_arena) {
      create_ts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_ts, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.create_ts_ = create_ts;
  // @@protoc_insertion_point(field_set_allocated:bedrock.dataserver.CreateShardRequest.create_ts)
}

// repeated string replicates = 4;
inline int CreateShardRequest::_internal_replicates_size() const {
  return _impl_.replicates_.size();
}
inline int CreateShardRequest::replicates_size() const {
  return _internal_replicates_size();
}
inline void CreateShardRequest::clear_replicates() {
  _impl_.replicates_.Clear();
}
inline std::string* CreateShardRequest::add_replicates() {
  std::string* _s = _internal_add_replicates();
  // @@protoc_insertion_point(field_add_mutable:bedrock.dataserver.CreateShardRequest.replicates)
  return _s;
}
inline const std::string& CreateShardRequest::_internal_replicates(int index) const {
  return _impl_.replicates_.Get(index);
}
inline const std::string& CreateShardRequest::replicates(int index) const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.CreateShardRequest.replicates)
  return _internal_replicates(index);
}
inline std::string* CreateShardRequest::mutable_replicates(int index) {
  // @@protoc_insertion_point(field_mutable:bedrock.dataserver.CreateShardRequest.replicates)
  return _impl_.replicates_.Mutable(index);
}
inline void CreateShardRequest::set_replicates(int index, const std::string& value) {
  _impl_.replicates_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bedrock.dataserver.CreateShardRequest.replicates)
}
inline void CreateShardRequest::set_replicates(int index, std::string&& value) {
  _impl_.replicates_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bedrock.dataserver.CreateShardRequest.replicates)
}
inline void CreateShardRequest::set_replicates(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.replicates_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bedrock.dataserver.CreateShardRequest.replicates)
}
inline void CreateShardRequest::set_replicates(int index, const char* value, size_t size) {
  _impl_.replicates_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bedrock.dataserver.CreateShardRequest.replicates)
}
inline std::string* CreateShardRequest::_internal_add_replicates() {
  return _impl_.replicates_.Add();
}
inline void CreateShardRequest::add_replicates(const std::string& value) {
  _impl_.replicates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bedrock.dataserver.CreateShardRequest.replicates)
}
inline void CreateShardRequest::add_replicates(std::string&& value) {
  _impl_.replicates_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bedrock.dataserver.CreateShardRequest.replicates)
}
inline void CreateShardRequest::add_replicates(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.replicates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bedrock.dataserver.CreateShardRequest.replicates)
}
inline void CreateShardRequest::add_replicates(const char* value, size_t size) {
  _impl_.replicates_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bedrock.dataserver.CreateShardRequest.replicates)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CreateShardRequest::replicates() const {
  // @@protoc_insertion_point(field_list:bedrock.dataserver.CreateShardRequest.replicates)
  return _impl_.replicates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CreateShardRequest::mutable_replicates() {
  // @@protoc_insertion_point(field_mutable_list:bedrock.dataserver.CreateShardRequest.replicates)
  return &_impl_.replicates_;
}

// .google.protobuf.Timestamp replica_update_ts = 5;
inline bool CreateShardRequest::_internal_has_replica_update_ts() const {
  return this != internal_default_instance() && _impl_.replica_update_ts_ != nullptr;
}
inline bool CreateShardRequest::has_replica_update_ts() const {
  return _internal_has_replica_update_ts();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CreateShardRequest::_internal_replica_update_ts() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.replica_update_ts_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CreateShardRequest::replica_update_ts() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.CreateShardRequest.replica_update_ts)
  return _internal_replica_update_ts();
}
inline void CreateShardRequest::unsafe_arena_set_allocated_replica_update_ts(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* replica_update_ts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.replica_update_ts_);
  }
  _impl_.replica_update_ts_ = replica_update_ts;
  if (replica_update_ts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bedrock.dataserver.CreateShardRequest.replica_update_ts)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateShardRequest::release_replica_update_ts() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.replica_update_ts_;
  _impl_.replica_update_ts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateShardRequest::unsafe_arena_release_replica_update_ts() {
  // @@protoc_insertion_point(field_release:bedrock.dataserver.CreateShardRequest.replica_update_ts)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.replica_update_ts_;
  _impl_.replica_update_ts_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateShardRequest::_internal_mutable_replica_update_ts() {
  
  if (_impl_.replica_update_ts_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.replica_update_ts_ = p;
  }
  return _impl_.replica_update_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateShardRequest::mutable_replica_update_ts() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_replica_update_ts();
  // @@protoc_insertion_point(field_mutable:bedrock.dataserver.CreateShardRequest.replica_update_ts)
  return _msg;
}
inline void CreateShardRequest::set_allocated_replica_update_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* replica_update_ts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.replica_update_ts_);
  }
  if (replica_update_ts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(replica_update_ts));
    if (message_arena != submessage_arena) {
      replica_update_ts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, replica_update_ts, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.replica_update_ts_ = replica_update_ts;
  // @@protoc_insertion_point(field_set_allocated:bedrock.dataserver.CreateShardRequest.replica_update_ts)
}

// string leader = 6;
inline void CreateShardRequest::clear_leader() {
  _impl_.leader_.ClearToEmpty();
}
inline const std::string& CreateShardRequest::leader() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.CreateShardRequest.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateShardRequest::set_leader(ArgT0&& arg0, ArgT... args) {
 
 _impl_.leader_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bedrock.dataserver.CreateShardRequest.leader)
}
inline std::string* CreateShardRequest::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:bedrock.dataserver.CreateShardRequest.leader)
  return _s;
}
inline const std::string& CreateShardRequest::_internal_leader() const {
  return _impl_.leader_.Get();
}
inline void CreateShardRequest::_internal_set_leader(const std::string& value) {
  
  _impl_.leader_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateShardRequest::_internal_mutable_leader() {
  
  return _impl_.leader_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateShardRequest::release_leader() {
  // @@protoc_insertion_point(field_release:bedrock.dataserver.CreateShardRequest.leader)
  return _impl_.leader_.Release();
}
inline void CreateShardRequest::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    
  } else {
    
  }
  _impl_.leader_.SetAllocated(leader, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leader_.IsDefault()) {
    _impl_.leader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bedrock.dataserver.CreateShardRequest.leader)
}

// .google.protobuf.Timestamp leader_change_ts = 7;
inline bool CreateShardRequest::_internal_has_leader_change_ts() const {
  return this != internal_default_instance() && _impl_.leader_change_ts_ != nullptr;
}
inline bool CreateShardRequest::has_leader_change_ts() const {
  return _internal_has_leader_change_ts();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CreateShardRequest::_internal_leader_change_ts() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.leader_change_ts_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CreateShardRequest::leader_change_ts() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.CreateShardRequest.leader_change_ts)
  return _internal_leader_change_ts();
}
inline void CreateShardRequest::unsafe_arena_set_allocated_leader_change_ts(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* leader_change_ts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.leader_change_ts_);
  }
  _impl_.leader_change_ts_ = leader_change_ts;
  if (leader_change_ts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bedrock.dataserver.CreateShardRequest.leader_change_ts)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateShardRequest::release_leader_change_ts() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.leader_change_ts_;
  _impl_.leader_change_ts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateShardRequest::unsafe_arena_release_leader_change_ts() {
  // @@protoc_insertion_point(field_release:bedrock.dataserver.CreateShardRequest.leader_change_ts)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.leader_change_ts_;
  _impl_.leader_change_ts_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateShardRequest::_internal_mutable_leader_change_ts() {
  
  if (_impl_.leader_change_ts_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.leader_change_ts_ = p;
  }
  return _impl_.leader_change_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateShardRequest::mutable_leader_change_ts() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_leader_change_ts();
  // @@protoc_insertion_point(field_mutable:bedrock.dataserver.CreateShardRequest.leader_change_ts)
  return _msg;
}
inline void CreateShardRequest::set_allocated_leader_change_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* leader_change_ts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.leader_change_ts_);
  }
  if (leader_change_ts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(leader_change_ts));
    if (message_arena != submessage_arena) {
      leader_change_ts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leader_change_ts, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.leader_change_ts_ = leader_change_ts;
  // @@protoc_insertion_point(field_set_allocated:bedrock.dataserver.CreateShardRequest.leader_change_ts)
}

// -------------------------------------------------------------------

// CreateShardResponse

// -------------------------------------------------------------------

// DeleteShardRequest

// uint64 shard_id = 1;
inline void DeleteShardRequest::clear_shard_id() {
  _impl_.shard_id_ = uint64_t{0u};
}
inline uint64_t DeleteShardRequest::_internal_shard_id() const {
  return _impl_.shard_id_;
}
inline uint64_t DeleteShardRequest::shard_id() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.DeleteShardRequest.shard_id)
  return _internal_shard_id();
}
inline void DeleteShardRequest::_internal_set_shard_id(uint64_t value) {
  
  _impl_.shard_id_ = value;
}
inline void DeleteShardRequest::set_shard_id(uint64_t value) {
  _internal_set_shard_id(value);
  // @@protoc_insertion_point(field_set:bedrock.dataserver.DeleteShardRequest.shard_id)
}

// -------------------------------------------------------------------

// DeleteShardResponse

// -------------------------------------------------------------------

// PullShardDataRequest

// -------------------------------------------------------------------

// PullShardDataResponse

// -------------------------------------------------------------------

// TransferShardRequest

// -------------------------------------------------------------------

// TransferShardResponse

// -------------------------------------------------------------------

// AddShardReplicaRequest

// -------------------------------------------------------------------

// AddShardReplicaResponse

// -------------------------------------------------------------------

// DeleteShardReplicaRequest

// -------------------------------------------------------------------

// DeleteShardReplicaResponse

// -------------------------------------------------------------------

// TransferShardLeaderRequest

// uint64 shard_id = 1;
inline void TransferShardLeaderRequest::clear_shard_id() {
  _impl_.shard_id_ = uint64_t{0u};
}
inline uint64_t TransferShardLeaderRequest::_internal_shard_id() const {
  return _impl_.shard_id_;
}
inline uint64_t TransferShardLeaderRequest::shard_id() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.TransferShardLeaderRequest.shard_id)
  return _internal_shard_id();
}
inline void TransferShardLeaderRequest::_internal_set_shard_id(uint64_t value) {
  
  _impl_.shard_id_ = value;
}
inline void TransferShardLeaderRequest::set_shard_id(uint64_t value) {
  _internal_set_shard_id(value);
  // @@protoc_insertion_point(field_set:bedrock.dataserver.TransferShardLeaderRequest.shard_id)
}

// repeated string replicates = 2;
inline int TransferShardLeaderRequest::_internal_replicates_size() const {
  return _impl_.replicates_.size();
}
inline int TransferShardLeaderRequest::replicates_size() const {
  return _internal_replicates_size();
}
inline void TransferShardLeaderRequest::clear_replicates() {
  _impl_.replicates_.Clear();
}
inline std::string* TransferShardLeaderRequest::add_replicates() {
  std::string* _s = _internal_add_replicates();
  // @@protoc_insertion_point(field_add_mutable:bedrock.dataserver.TransferShardLeaderRequest.replicates)
  return _s;
}
inline const std::string& TransferShardLeaderRequest::_internal_replicates(int index) const {
  return _impl_.replicates_.Get(index);
}
inline const std::string& TransferShardLeaderRequest::replicates(int index) const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.TransferShardLeaderRequest.replicates)
  return _internal_replicates(index);
}
inline std::string* TransferShardLeaderRequest::mutable_replicates(int index) {
  // @@protoc_insertion_point(field_mutable:bedrock.dataserver.TransferShardLeaderRequest.replicates)
  return _impl_.replicates_.Mutable(index);
}
inline void TransferShardLeaderRequest::set_replicates(int index, const std::string& value) {
  _impl_.replicates_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bedrock.dataserver.TransferShardLeaderRequest.replicates)
}
inline void TransferShardLeaderRequest::set_replicates(int index, std::string&& value) {
  _impl_.replicates_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bedrock.dataserver.TransferShardLeaderRequest.replicates)
}
inline void TransferShardLeaderRequest::set_replicates(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.replicates_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bedrock.dataserver.TransferShardLeaderRequest.replicates)
}
inline void TransferShardLeaderRequest::set_replicates(int index, const char* value, size_t size) {
  _impl_.replicates_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bedrock.dataserver.TransferShardLeaderRequest.replicates)
}
inline std::string* TransferShardLeaderRequest::_internal_add_replicates() {
  return _impl_.replicates_.Add();
}
inline void TransferShardLeaderRequest::add_replicates(const std::string& value) {
  _impl_.replicates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bedrock.dataserver.TransferShardLeaderRequest.replicates)
}
inline void TransferShardLeaderRequest::add_replicates(std::string&& value) {
  _impl_.replicates_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bedrock.dataserver.TransferShardLeaderRequest.replicates)
}
inline void TransferShardLeaderRequest::add_replicates(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.replicates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bedrock.dataserver.TransferShardLeaderRequest.replicates)
}
inline void TransferShardLeaderRequest::add_replicates(const char* value, size_t size) {
  _impl_.replicates_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bedrock.dataserver.TransferShardLeaderRequest.replicates)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TransferShardLeaderRequest::replicates() const {
  // @@protoc_insertion_point(field_list:bedrock.dataserver.TransferShardLeaderRequest.replicates)
  return _impl_.replicates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TransferShardLeaderRequest::mutable_replicates() {
  // @@protoc_insertion_point(field_mutable_list:bedrock.dataserver.TransferShardLeaderRequest.replicates)
  return &_impl_.replicates_;
}

// .google.protobuf.Timestamp leader_change_ts = 3;
inline bool TransferShardLeaderRequest::_internal_has_leader_change_ts() const {
  return this != internal_default_instance() && _impl_.leader_change_ts_ != nullptr;
}
inline bool TransferShardLeaderRequest::has_leader_change_ts() const {
  return _internal_has_leader_change_ts();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TransferShardLeaderRequest::_internal_leader_change_ts() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.leader_change_ts_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TransferShardLeaderRequest::leader_change_ts() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.TransferShardLeaderRequest.leader_change_ts)
  return _internal_leader_change_ts();
}
inline void TransferShardLeaderRequest::unsafe_arena_set_allocated_leader_change_ts(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* leader_change_ts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.leader_change_ts_);
  }
  _impl_.leader_change_ts_ = leader_change_ts;
  if (leader_change_ts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bedrock.dataserver.TransferShardLeaderRequest.leader_change_ts)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TransferShardLeaderRequest::release_leader_change_ts() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.leader_change_ts_;
  _impl_.leader_change_ts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TransferShardLeaderRequest::unsafe_arena_release_leader_change_ts() {
  // @@protoc_insertion_point(field_release:bedrock.dataserver.TransferShardLeaderRequest.leader_change_ts)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.leader_change_ts_;
  _impl_.leader_change_ts_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TransferShardLeaderRequest::_internal_mutable_leader_change_ts() {
  
  if (_impl_.leader_change_ts_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.leader_change_ts_ = p;
  }
  return _impl_.leader_change_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TransferShardLeaderRequest::mutable_leader_change_ts() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_leader_change_ts();
  // @@protoc_insertion_point(field_mutable:bedrock.dataserver.TransferShardLeaderRequest.leader_change_ts)
  return _msg;
}
inline void TransferShardLeaderRequest::set_allocated_leader_change_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* leader_change_ts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.leader_change_ts_);
  }
  if (leader_change_ts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(leader_change_ts));
    if (message_arena != submessage_arena) {
      leader_change_ts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leader_change_ts, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.leader_change_ts_ = leader_change_ts;
  // @@protoc_insertion_point(field_set_allocated:bedrock.dataserver.TransferShardLeaderRequest.leader_change_ts)
}

// -------------------------------------------------------------------

// TransferShardLeaderResponse

// -------------------------------------------------------------------

// LockShardRequest

// -------------------------------------------------------------------

// LockShardResponse

// -------------------------------------------------------------------

// UnlockShardRequest

// -------------------------------------------------------------------

// UnlockShardResponse

// -------------------------------------------------------------------

// ShardReadRequest

// uint64 shard_id = 1;
inline void ShardReadRequest::clear_shard_id() {
  _impl_.shard_id_ = uint64_t{0u};
}
inline uint64_t ShardReadRequest::_internal_shard_id() const {
  return _impl_.shard_id_;
}
inline uint64_t ShardReadRequest::shard_id() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardReadRequest.shard_id)
  return _internal_shard_id();
}
inline void ShardReadRequest::_internal_set_shard_id(uint64_t value) {
  
  _impl_.shard_id_ = value;
}
inline void ShardReadRequest::set_shard_id(uint64_t value) {
  _internal_set_shard_id(value);
  // @@protoc_insertion_point(field_set:bedrock.dataserver.ShardReadRequest.shard_id)
}

// bytes key = 2;
inline void ShardReadRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& ShardReadRequest::key() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardReadRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShardReadRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bedrock.dataserver.ShardReadRequest.key)
}
inline std::string* ShardReadRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:bedrock.dataserver.ShardReadRequest.key)
  return _s;
}
inline const std::string& ShardReadRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void ShardReadRequest::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* ShardReadRequest::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* ShardReadRequest::release_key() {
  // @@protoc_insertion_point(field_release:bedrock.dataserver.ShardReadRequest.key)
  return _impl_.key_.Release();
}
inline void ShardReadRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bedrock.dataserver.ShardReadRequest.key)
}

// -------------------------------------------------------------------

// ShardReadResponse

// bytes value = 1;
inline void ShardReadResponse::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& ShardReadResponse::value() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardReadResponse.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShardReadResponse::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bedrock.dataserver.ShardReadResponse.value)
}
inline std::string* ShardReadResponse::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:bedrock.dataserver.ShardReadResponse.value)
  return _s;
}
inline const std::string& ShardReadResponse::_internal_value() const {
  return _impl_.value_.Get();
}
inline void ShardReadResponse::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* ShardReadResponse::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* ShardReadResponse::release_value() {
  // @@protoc_insertion_point(field_release:bedrock.dataserver.ShardReadResponse.value)
  return _impl_.value_.Release();
}
inline void ShardReadResponse::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bedrock.dataserver.ShardReadResponse.value)
}

// -------------------------------------------------------------------

// ShardWriteRequest

// uint64 shard_id = 1;
inline void ShardWriteRequest::clear_shard_id() {
  _impl_.shard_id_ = uint64_t{0u};
}
inline uint64_t ShardWriteRequest::_internal_shard_id() const {
  return _impl_.shard_id_;
}
inline uint64_t ShardWriteRequest::shard_id() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardWriteRequest.shard_id)
  return _internal_shard_id();
}
inline void ShardWriteRequest::_internal_set_shard_id(uint64_t value) {
  
  _impl_.shard_id_ = value;
}
inline void ShardWriteRequest::set_shard_id(uint64_t value) {
  _internal_set_shard_id(value);
  // @@protoc_insertion_point(field_set:bedrock.dataserver.ShardWriteRequest.shard_id)
}

// bytes key = 2;
inline void ShardWriteRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& ShardWriteRequest::key() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardWriteRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShardWriteRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bedrock.dataserver.ShardWriteRequest.key)
}
inline std::string* ShardWriteRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:bedrock.dataserver.ShardWriteRequest.key)
  return _s;
}
inline const std::string& ShardWriteRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void ShardWriteRequest::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* ShardWriteRequest::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* ShardWriteRequest::release_key() {
  // @@protoc_insertion_point(field_release:bedrock.dataserver.ShardWriteRequest.key)
  return _impl_.key_.Release();
}
inline void ShardWriteRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bedrock.dataserver.ShardWriteRequest.key)
}

// bytes value = 3;
inline void ShardWriteRequest::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& ShardWriteRequest::value() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardWriteRequest.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShardWriteRequest::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bedrock.dataserver.ShardWriteRequest.value)
}
inline std::string* ShardWriteRequest::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:bedrock.dataserver.ShardWriteRequest.value)
  return _s;
}
inline const std::string& ShardWriteRequest::_internal_value() const {
  return _impl_.value_.Get();
}
inline void ShardWriteRequest::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* ShardWriteRequest::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* ShardWriteRequest::release_value() {
  // @@protoc_insertion_point(field_release:bedrock.dataserver.ShardWriteRequest.value)
  return _impl_.value_.Release();
}
inline void ShardWriteRequest::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bedrock.dataserver.ShardWriteRequest.value)
}

// -------------------------------------------------------------------

// ShardWriteResponse

// bool not_leader = 1;
inline void ShardWriteResponse::clear_not_leader() {
  _impl_.not_leader_ = false;
}
inline bool ShardWriteResponse::_internal_not_leader() const {
  return _impl_.not_leader_;
}
inline bool ShardWriteResponse::not_leader() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardWriteResponse.not_leader)
  return _internal_not_leader();
}
inline void ShardWriteResponse::_internal_set_not_leader(bool value) {
  
  _impl_.not_leader_ = value;
}
inline void ShardWriteResponse::set_not_leader(bool value) {
  _internal_set_not_leader(value);
  // @@protoc_insertion_point(field_set:bedrock.dataserver.ShardWriteResponse.not_leader)
}

// -------------------------------------------------------------------

// ShardAppendLogRequest_Entry

// string op = 1;
inline void ShardAppendLogRequest_Entry::clear_op() {
  _impl_.op_.ClearToEmpty();
}
inline const std::string& ShardAppendLogRequest_Entry::op() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardAppendLogRequest.Entry.op)
  return _internal_op();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShardAppendLogRequest_Entry::set_op(ArgT0&& arg0, ArgT... args) {
 
 _impl_.op_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bedrock.dataserver.ShardAppendLogRequest.Entry.op)
}
inline std::string* ShardAppendLogRequest_Entry::mutable_op() {
  std::string* _s = _internal_mutable_op();
  // @@protoc_insertion_point(field_mutable:bedrock.dataserver.ShardAppendLogRequest.Entry.op)
  return _s;
}
inline const std::string& ShardAppendLogRequest_Entry::_internal_op() const {
  return _impl_.op_.Get();
}
inline void ShardAppendLogRequest_Entry::_internal_set_op(const std::string& value) {
  
  _impl_.op_.Set(value, GetArenaForAllocation());
}
inline std::string* ShardAppendLogRequest_Entry::_internal_mutable_op() {
  
  return _impl_.op_.Mutable(GetArenaForAllocation());
}
inline std::string* ShardAppendLogRequest_Entry::release_op() {
  // @@protoc_insertion_point(field_release:bedrock.dataserver.ShardAppendLogRequest.Entry.op)
  return _impl_.op_.Release();
}
inline void ShardAppendLogRequest_Entry::set_allocated_op(std::string* op) {
  if (op != nullptr) {
    
  } else {
    
  }
  _impl_.op_.SetAllocated(op, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.op_.IsDefault()) {
    _impl_.op_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bedrock.dataserver.ShardAppendLogRequest.Entry.op)
}

// uint64 index = 2;
inline void ShardAppendLogRequest_Entry::clear_index() {
  _impl_.index_ = uint64_t{0u};
}
inline uint64_t ShardAppendLogRequest_Entry::_internal_index() const {
  return _impl_.index_;
}
inline uint64_t ShardAppendLogRequest_Entry::index() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardAppendLogRequest.Entry.index)
  return _internal_index();
}
inline void ShardAppendLogRequest_Entry::_internal_set_index(uint64_t value) {
  
  _impl_.index_ = value;
}
inline void ShardAppendLogRequest_Entry::set_index(uint64_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:bedrock.dataserver.ShardAppendLogRequest.Entry.index)
}

// bytes key = 3;
inline void ShardAppendLogRequest_Entry::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& ShardAppendLogRequest_Entry::key() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardAppendLogRequest.Entry.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShardAppendLogRequest_Entry::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bedrock.dataserver.ShardAppendLogRequest.Entry.key)
}
inline std::string* ShardAppendLogRequest_Entry::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:bedrock.dataserver.ShardAppendLogRequest.Entry.key)
  return _s;
}
inline const std::string& ShardAppendLogRequest_Entry::_internal_key() const {
  return _impl_.key_.Get();
}
inline void ShardAppendLogRequest_Entry::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* ShardAppendLogRequest_Entry::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* ShardAppendLogRequest_Entry::release_key() {
  // @@protoc_insertion_point(field_release:bedrock.dataserver.ShardAppendLogRequest.Entry.key)
  return _impl_.key_.Release();
}
inline void ShardAppendLogRequest_Entry::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bedrock.dataserver.ShardAppendLogRequest.Entry.key)
}

// bytes value = 4;
inline void ShardAppendLogRequest_Entry::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& ShardAppendLogRequest_Entry::value() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardAppendLogRequest.Entry.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShardAppendLogRequest_Entry::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bedrock.dataserver.ShardAppendLogRequest.Entry.value)
}
inline std::string* ShardAppendLogRequest_Entry::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:bedrock.dataserver.ShardAppendLogRequest.Entry.value)
  return _s;
}
inline const std::string& ShardAppendLogRequest_Entry::_internal_value() const {
  return _impl_.value_.Get();
}
inline void ShardAppendLogRequest_Entry::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* ShardAppendLogRequest_Entry::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* ShardAppendLogRequest_Entry::release_value() {
  // @@protoc_insertion_point(field_release:bedrock.dataserver.ShardAppendLogRequest.Entry.value)
  return _impl_.value_.Release();
}
inline void ShardAppendLogRequest_Entry::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bedrock.dataserver.ShardAppendLogRequest.Entry.value)
}

// -------------------------------------------------------------------

// ShardAppendLogRequest

// uint64 shard_id = 1;
inline void ShardAppendLogRequest::clear_shard_id() {
  _impl_.shard_id_ = uint64_t{0u};
}
inline uint64_t ShardAppendLogRequest::_internal_shard_id() const {
  return _impl_.shard_id_;
}
inline uint64_t ShardAppendLogRequest::shard_id() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardAppendLogRequest.shard_id)
  return _internal_shard_id();
}
inline void ShardAppendLogRequest::_internal_set_shard_id(uint64_t value) {
  
  _impl_.shard_id_ = value;
}
inline void ShardAppendLogRequest::set_shard_id(uint64_t value) {
  _internal_set_shard_id(value);
  // @@protoc_insertion_point(field_set:bedrock.dataserver.ShardAppendLogRequest.shard_id)
}

// .google.protobuf.Timestamp leader_change_ts = 2;
inline bool ShardAppendLogRequest::_internal_has_leader_change_ts() const {
  return this != internal_default_instance() && _impl_.leader_change_ts_ != nullptr;
}
inline bool ShardAppendLogRequest::has_leader_change_ts() const {
  return _internal_has_leader_change_ts();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ShardAppendLogRequest::_internal_leader_change_ts() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.leader_change_ts_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ShardAppendLogRequest::leader_change_ts() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardAppendLogRequest.leader_change_ts)
  return _internal_leader_change_ts();
}
inline void ShardAppendLogRequest::unsafe_arena_set_allocated_leader_change_ts(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* leader_change_ts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.leader_change_ts_);
  }
  _impl_.leader_change_ts_ = leader_change_ts;
  if (leader_change_ts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bedrock.dataserver.ShardAppendLogRequest.leader_change_ts)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ShardAppendLogRequest::release_leader_change_ts() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.leader_change_ts_;
  _impl_.leader_change_ts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ShardAppendLogRequest::unsafe_arena_release_leader_change_ts() {
  // @@protoc_insertion_point(field_release:bedrock.dataserver.ShardAppendLogRequest.leader_change_ts)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.leader_change_ts_;
  _impl_.leader_change_ts_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ShardAppendLogRequest::_internal_mutable_leader_change_ts() {
  
  if (_impl_.leader_change_ts_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.leader_change_ts_ = p;
  }
  return _impl_.leader_change_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ShardAppendLogRequest::mutable_leader_change_ts() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_leader_change_ts();
  // @@protoc_insertion_point(field_mutable:bedrock.dataserver.ShardAppendLogRequest.leader_change_ts)
  return _msg;
}
inline void ShardAppendLogRequest::set_allocated_leader_change_ts(::PROTOBUF_NAMESPACE_ID::Timestamp* leader_change_ts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.leader_change_ts_);
  }
  if (leader_change_ts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(leader_change_ts));
    if (message_arena != submessage_arena) {
      leader_change_ts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leader_change_ts, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.leader_change_ts_ = leader_change_ts;
  // @@protoc_insertion_point(field_set_allocated:bedrock.dataserver.ShardAppendLogRequest.leader_change_ts)
}

// repeated .bedrock.dataserver.ShardAppendLogRequest.Entry entries = 3;
inline int ShardAppendLogRequest::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int ShardAppendLogRequest::entries_size() const {
  return _internal_entries_size();
}
inline void ShardAppendLogRequest::clear_entries() {
  _impl_.entries_.Clear();
}
inline ::bedrock::dataserver::ShardAppendLogRequest_Entry* ShardAppendLogRequest::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:bedrock.dataserver.ShardAppendLogRequest.entries)
  return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bedrock::dataserver::ShardAppendLogRequest_Entry >*
ShardAppendLogRequest::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:bedrock.dataserver.ShardAppendLogRequest.entries)
  return &_impl_.entries_;
}
inline const ::bedrock::dataserver::ShardAppendLogRequest_Entry& ShardAppendLogRequest::_internal_entries(int index) const {
  return _impl_.entries_.Get(index);
}
inline const ::bedrock::dataserver::ShardAppendLogRequest_Entry& ShardAppendLogRequest::entries(int index) const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardAppendLogRequest.entries)
  return _internal_entries(index);
}
inline ::bedrock::dataserver::ShardAppendLogRequest_Entry* ShardAppendLogRequest::_internal_add_entries() {
  return _impl_.entries_.Add();
}
inline ::bedrock::dataserver::ShardAppendLogRequest_Entry* ShardAppendLogRequest::add_entries() {
  ::bedrock::dataserver::ShardAppendLogRequest_Entry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:bedrock.dataserver.ShardAppendLogRequest.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bedrock::dataserver::ShardAppendLogRequest_Entry >&
ShardAppendLogRequest::entries() const {
  // @@protoc_insertion_point(field_list:bedrock.dataserver.ShardAppendLogRequest.entries)
  return _impl_.entries_;
}

// -------------------------------------------------------------------

// ShardAppendLogResponse

// bool is_old_leader = 1;
inline void ShardAppendLogResponse::clear_is_old_leader() {
  _impl_.is_old_leader_ = false;
}
inline bool ShardAppendLogResponse::_internal_is_old_leader() const {
  return _impl_.is_old_leader_;
}
inline bool ShardAppendLogResponse::is_old_leader() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardAppendLogResponse.is_old_leader)
  return _internal_is_old_leader();
}
inline void ShardAppendLogResponse::_internal_set_is_old_leader(bool value) {
  
  _impl_.is_old_leader_ = value;
}
inline void ShardAppendLogResponse::set_is_old_leader(bool value) {
  _internal_set_is_old_leader(value);
  // @@protoc_insertion_point(field_set:bedrock.dataserver.ShardAppendLogResponse.is_old_leader)
}

// uint64 last_applied_index = 2;
inline void ShardAppendLogResponse::clear_last_applied_index() {
  _impl_.last_applied_index_ = uint64_t{0u};
}
inline uint64_t ShardAppendLogResponse::_internal_last_applied_index() const {
  return _impl_.last_applied_index_;
}
inline uint64_t ShardAppendLogResponse::last_applied_index() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardAppendLogResponse.last_applied_index)
  return _internal_last_applied_index();
}
inline void ShardAppendLogResponse::_internal_set_last_applied_index(uint64_t value) {
  
  _impl_.last_applied_index_ = value;
}
inline void ShardAppendLogResponse::set_last_applied_index(uint64_t value) {
  _internal_set_last_applied_index(value);
  // @@protoc_insertion_point(field_set:bedrock.dataserver.ShardAppendLogResponse.last_applied_index)
}

// -------------------------------------------------------------------

// ShardInstallSnapshotRequest

// uint64 shard_id = 1;
inline void ShardInstallSnapshotRequest::clear_shard_id() {
  _impl_.shard_id_ = uint64_t{0u};
}
inline uint64_t ShardInstallSnapshotRequest::_internal_shard_id() const {
  return _impl_.shard_id_;
}
inline uint64_t ShardInstallSnapshotRequest::shard_id() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardInstallSnapshotRequest.shard_id)
  return _internal_shard_id();
}
inline void ShardInstallSnapshotRequest::_internal_set_shard_id(uint64_t value) {
  
  _impl_.shard_id_ = value;
}
inline void ShardInstallSnapshotRequest::set_shard_id(uint64_t value) {
  _internal_set_shard_id(value);
  // @@protoc_insertion_point(field_set:bedrock.dataserver.ShardInstallSnapshotRequest.shard_id)
}

// bytes data_piece = 2;
inline void ShardInstallSnapshotRequest::clear_data_piece() {
  _impl_.data_piece_.ClearToEmpty();
}
inline const std::string& ShardInstallSnapshotRequest::data_piece() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardInstallSnapshotRequest.data_piece)
  return _internal_data_piece();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShardInstallSnapshotRequest::set_data_piece(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_piece_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bedrock.dataserver.ShardInstallSnapshotRequest.data_piece)
}
inline std::string* ShardInstallSnapshotRequest::mutable_data_piece() {
  std::string* _s = _internal_mutable_data_piece();
  // @@protoc_insertion_point(field_mutable:bedrock.dataserver.ShardInstallSnapshotRequest.data_piece)
  return _s;
}
inline const std::string& ShardInstallSnapshotRequest::_internal_data_piece() const {
  return _impl_.data_piece_.Get();
}
inline void ShardInstallSnapshotRequest::_internal_set_data_piece(const std::string& value) {
  
  _impl_.data_piece_.Set(value, GetArenaForAllocation());
}
inline std::string* ShardInstallSnapshotRequest::_internal_mutable_data_piece() {
  
  return _impl_.data_piece_.Mutable(GetArenaForAllocation());
}
inline std::string* ShardInstallSnapshotRequest::release_data_piece() {
  // @@protoc_insertion_point(field_release:bedrock.dataserver.ShardInstallSnapshotRequest.data_piece)
  return _impl_.data_piece_.Release();
}
inline void ShardInstallSnapshotRequest::set_allocated_data_piece(std::string* data_piece) {
  if (data_piece != nullptr) {
    
  } else {
    
  }
  _impl_.data_piece_.SetAllocated(data_piece, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_piece_.IsDefault()) {
    _impl_.data_piece_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bedrock.dataserver.ShardInstallSnapshotRequest.data_piece)
}

// uint64 last_wal_index = 3;
inline void ShardInstallSnapshotRequest::clear_last_wal_index() {
  _impl_.last_wal_index_ = uint64_t{0u};
}
inline uint64_t ShardInstallSnapshotRequest::_internal_last_wal_index() const {
  return _impl_.last_wal_index_;
}
inline uint64_t ShardInstallSnapshotRequest::last_wal_index() const {
  // @@protoc_insertion_point(field_get:bedrock.dataserver.ShardInstallSnapshotRequest.last_wal_index)
  return _internal_last_wal_index();
}
inline void ShardInstallSnapshotRequest::_internal_set_last_wal_index(uint64_t value) {
  
  _impl_.last_wal_index_ = value;
}
inline void ShardInstallSnapshotRequest::set_last_wal_index(uint64_t value) {
  _internal_set_last_wal_index(value);
  // @@protoc_insertion_point(field_set:bedrock.dataserver.ShardInstallSnapshotRequest.last_wal_index)
}

// -------------------------------------------------------------------

// ShardInstallSnapshotResponse

// -------------------------------------------------------------------

// ShardWriteReplicaRequest

// -------------------------------------------------------------------

// ShardWriteReplicaResponse

// -------------------------------------------------------------------

// ShardRepairRequest

// -------------------------------------------------------------------

// ShardRepairResponse

// -------------------------------------------------------------------

// DataServerJoinRequest

// -------------------------------------------------------------------

// DataServerJoinResponse

// -------------------------------------------------------------------

// DataServerLeaveRequest

// -------------------------------------------------------------------

// DataServerLeaveResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace dataserver
}  // namespace bedrock

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_dataserver_2eproto
